<!DOCTYPE html>
<html>
<head>
    <!-- [[! Document Settings ]] -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- [[! Page Meta ]] -->
    <title>Finding The Way Home</title>
    <meta name="description" content="raycoarana - My coding adventures and other random stuff" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="/assets/images/favicon.ico" >

    <!-- [[! Styles'n'Scripts ]] -->
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css"
          href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/assets/css/syntax.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/contact.css" />

    <script type="text/javascript" src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
    
        <link rel="canonical" href="/" />
    <meta name="referrer" content="origin" />

    <meta property="og:site_name" content="raycoarana" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="raycoarana" />
    <meta property="og:description" content="My coding adventures and other random stuff" />
    <meta property="og:url" content="/" />
    <meta property="og:image" content="/assets/images/cover1.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="raycoarana" />
    <meta name="twitter:description" content="My coding adventures and other random stuff" />
    <meta name="twitter:url" content="/" />
    <meta name="twitter:image:src" content="/assets/images/cover1.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "Finding The Way Home",
    "url": "/",
    "image": "/assets/images/cover1.jpg",
    "description": "My coding adventures and other random stuff"
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="raycoarana" href="/feed.xml" />
</head>
<body class="paged archive-template nav-closed">

    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home  nav-current" role="presentation"><a href="/">Home</a></li>
        <li class="nav-development " role="presentation"><a href="/tag/development">Development</a></li>
        <li class="nav-author " role="presentation"><a href="/author/raycoarana">Author</a></li>
        <li class="nav-about " role="presentation"><a href="/about">About</a></li>
        <li class="nav-contact " role="presentation"><a href="/contact">Contact</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- < default -->
<!-- The tag above means - insert everything in this file into the [body] of the default.hbs template -->

<!-- The big featured header  -->
<header class="main-header "
        style="background-image: url(/assets/images/cover1.jpg) ">
    <nav class="main-nav overlay clearfix">
        <a class="blog-logo" href="/"><img src="/assets/images/main-logo.png" alt="Blog Logo" /></a>
        
            <a class="menu-button icon-menu" href><span class="word">Menu</span></a>
        
    </nav>
    <div class="vertical">
        <div class="main-header-content inner">
            <h1 class="page-title">raycoarana</h1>
            <h2 class="page-description">My coding adventures and other random stuff</h2>
        </div>
    </div>
    <a class="scroll-down icon-arrow-left" href="#content" data-offset="-45"><span class="hidden">Scroll Down</span></a>
</header>

<!-- The main content area on the homepage -->
<main id="content" class="content" role="main">

    <!-- The tag below includes the post loop - partials/loop.hbs -->
        <!-- Previous/next page links - only displayed on page 2+ -->
    <div class="extra-pagination inner">
        
            <nav class="pagination" role="pagination">
    
        
            <a class="newer-posts" href="/" title="Previous Page">&laquo; Newer Posts</a>
        
    
    <span class="page-number"> Page 2 of 4 </span>
     
        <a class="older-posts" href="/page3/" title="Next Page">Older Posts &raquo;</a>
     
</nav>
        
    </div>

    <!-- This is the post loop - each post will be output using this markup -->
    
    <article class="post">
        <header class="post-header">
            <h2 class="post-title"><a href="/blog/2014/06/prototipado-de-apps-con-wireframesketcher/">Prototipado de apps con WireframeSketcher</a></h2>
        </header>
        <section class="post-excerpt">
            <p>Aunque este es un blog fundamentalmente de desarrollo, hoy quería comentar un poco algo que nos toca siempre al comenzar una aplicación: la conceptualización. En el desarrollo móvil no es ningún secreto que tenemos <strong>el problema del tamaño de la pantalla</strong> -a pesar de los pseudo tablets que tenemos ahora por teléfonos-. A la hora de conceptualizar la aplicación, es fundamental utilizar una <strong>herramienta que nos permita de forma rápida poder organizar la información</strong> y cómo se comportará nuestra app.</p>

<p>Desde hace un tiempo he estado buscando la mejor herramienta para esta labor. Algo fundamental que debe tener una herramienta de este tipo es que <strong>respete las proporciones de los componentes nativos</strong> de la plataforma. Sin esto, conceptualizar una pantalla es un disparate, ya que estamos organizando la información en base a una premisa que puede ser falsa y a la hora de llevarla a la práctica, podemos ver que las cosas no nos caben -o nos sobra espacio-. En esta búsqueda me he topado con <strong>WireframeSketcher</strong>, una herramienta la mar de interesante, basada en Eclipse y con todos los elementos nativos de Android 4.X -también tiene los de iOS y Windows Phone entre otros-. Vamos a ver las principales características de esta herramienta.</p>

 <a class="read-more" href="/blog/2014/06/prototipado-de-apps-con-wireframesketcher/">&raquo;</a>
        </section>
        <footer class="post-meta">
            <img class="author-thumb" src="/assets/images/avatar.jpg" alt="Author image" nopin="nopin" />
            <!-- author -->
            <a href='/author/raycoarana'>Rayco Araña</a>
            <!-- [[tags prefix=" on "]] -->
             
                on 
                
                    
                       <a href='/tag/android'>Android</a>,
                       
                
                    
                       <a href='/tag/assets'>Assets</a>,
                       
                
                    
                       <a href='/tag/prototipado'>Prototipado</a>,
                       
                
                    
                       <a href='/tag/wireframe'>Wireframe</a>,
                       
                
                    
                       <a href='/tag/wireframesketcher'>Wireframesketcher</a>,
                       
                
                    
                       <a href='/tag/design'>Design</a>
                       
                
            
            <time class="post-date" datetime="2014-06-19">19 Jun 2014</time>
        </footer>
    </article>
    
    <article class="post">
        <header class="post-header">
            <h2 class="post-title"><a href="/blog/2014/06/calligraphy-fuentes-personalizadas-android/">Calligraphy, fuentes personalizadas en Android</a></h2>
        </header>
        <section class="post-excerpt">
            <p>Si hay una cosa que es un <strong>dolor de muelas</strong> en Android es cuando tienes que hacer una app que usa <strong>fuentes personalizadas</strong>. Aunque es incluso peor, si queremos usar la moderna Roboto, ya tenemos el lío formado, ya que en Android 2.3 no la tendremos tampoco. Y es que utilizar fuentes personalizadas es algo que está muy mal resuelto incluso aún hoy en la última versión del sistema (4.4.3 a día de hoy).</p>

<p>Básicamente para establecer una fuente distinta a las que trae el sistema por defecto, debemos instanciar la fuente (que normalmente tendremos en la carpeta <strong>assets</strong>) y asignarla a la vista de turno. El código sería algo así de horrible (horrible porque hacer esto por cada vista es una locura desde el punto de vista de mantenimiento de este tipo de código).</p>

<p>[code language=”java”]
Typeface tf = Typeface.createFromAsset(getAssets(), 
                                       “fonts/mycustomfont.ttf”);</p>

<p>TextView myView = (TextView) findViewById(android.R.id.text1);
myView.setTypeface(tf);
[/code]</p>

<p>Vamos a ver algunas formas para mejorar lo anterior y dejar que nuestras vistas se <strong>definan de forma declarativa</strong> por completo en el XML del layout.</p>

<!-- more -->

<p>[sh_margin margin=”20”]</p>

<h3 id="solución-1-controles-personalizados">Solución 1. Controles personalizados</h3>

<p>Una primera solución a este problema es utilizar controles personalizados para agregarles un atributo en el que indiquemos que fuente utilizar. Existen varias librerías que implementan esta forma de trabajo con las que simplemente debes utilizar sus vistas en vez de las vistas por defecto. Por ejemplo la librería <a href="https://github.com/neopixl/PixlUI">PixlUI</a> utiliza esta aproximación.</p>

<p>¿Desventajas de esta forma de trabajo? Pues que implica agregar una dependencia en todo el proyecto con esta librería, introduciendo sus atributos propios en las vistas. Además lo peor es que el editor de layouts pierde muchas veces la capacidad de mostrar el predictivo a la hora de escribir atributos. Además las vistas nos quedarán con esos <strong>nombres de controles enormes</strong> que incluyen el nombre del paquete de la clase y hacen menos legible nuestro código.</p>

<p>[code language=”xml”]
<?xml version="1.0" encoding="utf-8"?></p>

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:pixlui="http://schemas.android.com/apk/com.neopixl.pixlui" android:layout_width="match_parent" android:layout_height="match_parent">

    <com.neopixl.pixlui.components.textview.TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/text_of_my_view" android:gravity="center" android:textSize="36sp" pixlui:typeface="mycustomfont.ttf" />

...

</LinearLayout>
<p>[/code]</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="solución-2-calligraphy">Solución 2. Calligraphy</h3>

<p>Esta otra solución, implementada por esta librería llamada Calligraphy es tremendamente interesante, con <strong>una aproximación mucho más elegante</strong> a la hora de resolver el problema. En vez de regar nuestra aplicación con referencias a controles externos, esta librería crea un <strong>Wrapper tanto al objeto Context como al objeto LayoutInflater</strong> para interceptar toda referencia a las clases <em>TextView</em>, <em>Button</em>, <em>EditText</em>, <em>AutoCompleteTextView</em>, <em>MultiAutoCompleteTextView</em>, <em>CheckBox</em>, <em>RadioButton</em> y <em>ToggleButton</em>. Cuando detecta la instanciación de cualquiera de estos en nuestro <em>layout</em>, crea la fuente asociada y se la asigna a la vista. Esto además haciendo uso de una caché de fuentes y demás optimizaciones.</p>

<p>Para que esto funcione, lo que tendremos que hacer es <strong>envolver</strong> el contexto de nuestra actividad con este <strong>Wrapper</strong>, haciendo lo siguiente:</p>

<p>[code language=”java”]
@Override
protected void attachBaseContext(Context newBase) {
    super.attachBaseContext(new CalligraphyContextWrapper(newBase));
}
[/code]</p>

<p>Ahora solo nos queda indicar que fuente queremos usar en las vistas, retomando el ejemplo anterior, sería algo así:</p>

<p>[code language=”xml”]
<?xml version="1.0" encoding="utf-8"?></p>

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent">

    <TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/text_of_my_view" android:gravity="center" android:textSize="36sp" android:fontFamily="fonts/mycustomfont.ttf" />

...

</LinearLayout>
<p>[/code]</p>

<p>Por defecto como puedes ver se reutiliza la propiedad <strong>fontFamily</strong> para indicar la fuente que queremos usar, si bien esto nos puede acarrear problemas a futuro si Google cambia el uso de esa propiedad o le da otro uso (aunque esto sería muy raro). Calligraphy nos ofrece <strong>la posibilidad de usar un atributo personalizado</strong>, para ello primero debemos crearnos el atributo, en el fichero attrbs.xml por ejemplo.</p>

<p>[code language=”xml”]
<?xml version="1.0" encoding="utf-8"?></p>
<Resources>
    <attr name="customFont" />
</Resources>
<p>[/code]</p>

<p>Ahora necesitamos indicarle a Calligraphy cual es el atributo que vamos a usar.</p>

<p>[code language=”java”]
@Override
protected void attachBaseContext(Context newBase) {
    super.attachBaseContext(new CalligraphyContextWrapper(newBase, R.attr.customFont));
}
[/code]</p>

<p>Y ya solo nos queda utilizarlo en las vistas.</p>

<p>[code language=”xml”]
<?xml version="1.0" encoding="utf-8"?></p>

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent">

    <TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/text_of_my_view" android:gravity="center" android:textSize="36sp" customFont="fonts/mycustomfont.ttf" />

...

</LinearLayout>
<p>[/code]</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="conclusiones">Conclusiones</h3>

<p>Sin duda Calligraphy <strong>es lo que Google debería haber soportado en Android desde hace mucho tiempo</strong>. Integrándolo en la librería de compatibilidad abriría incluso su uso en cualquier versión de la API. Su solución es bastante limpia, no acopla todo nuestro código a controles personalizados y nos permite gestionar todo con estilos y temas, por lo que <strong>podemos centralizar el uso de las fuentes en nuestros ficheros de estilos</strong>. Os dejo el enlace al repositorio donde podéis encontrar el código y ver cómo funciona.</p>

<p>[github repo=”chrisjenx/Calligraphy”]</p>
 <a class="read-more" href="/blog/2014/06/calligraphy-fuentes-personalizadas-android/">&raquo;</a>
        </section>
        <footer class="post-meta">
            <img class="author-thumb" src="/assets/images/avatar.jpg" alt="Author image" nopin="nopin" />
            <!-- author -->
            <a href='/author/raycoarana'>Rayco Araña</a>
            <!-- [[tags prefix=" on "]] -->
             
                on 
                
                    
                       <a href='/tag/android'>Android</a>,
                       
                
                    
                       <a href='/tag/calligraphy'>Calligraphy</a>,
                       
                
                    
                       <a href='/tag/fuentes'>Fuentes</a>,
                       
                
                    
                       <a href='/tag/personalizadas'>Personalizadas</a>
                       
                
            
            <time class="post-date" datetime="2014-06-16">16 Jun 2014</time>
        </footer>
    </article>
    
    <article class="post">
        <header class="post-header">
            <h2 class="post-title"><a href="/blog/2014/06/parcelables-con-android-autoparcel/">Parcelables con Android AutoParcel</a></h2>
        </header>
        <section class="post-excerpt">
            <p>Cuando vamos a crear una app en Android y tenemos que pasar datos entre <strong>Activities</strong> y/o <strong>Fragments</strong>, el sistema operativo nos brinda la posibilidad de usar un <strong>Bundle</strong>, ya sea a través del <strong>Intent **(y el Bundle de extras) o a través del método <em>**setArguments()**</em> de los Fragments. Esta es la manera idónea de pasar datos entre componentes, ya que **no crea acoplamientos poco deseables</strong>, además estos se gestionan de manera automática por el sistema, por lo que no debemos preocuparnos de qué pasa con ellos si el sistema ha tenido que recrear el Activity o Fragment debido al ciclo de vida de la aplicación.</p>

<p>El problema viene con los tipos de datos que nos permite almacenar un Bundle, estos son tipos básicos u objetos que implementen la interfaz <strong>Serializable</strong> o <strong>Parcelable</strong>. A la hora de implementar una u otra interfaz, la primera es sencilla, con solo hacer que nuestra clase implemente la interfaz Serializable el sistema <strong>por medio de reflexión es capaz de serializar el objeto a una representación binaria</strong> que se puede persistir. En el caso de Parcelable, sin embargo, debemos implementar dos métodos para serializar -_writeToParcel()<em>- y deserializar -_constructor</em>- el objeto. Además debemos escribirlo con sumo cuidado y en perfecto orden inverso o no funcionará, algo muy <strong>tedioso y difícil de mantener</strong>.</p>

<!-- more -->

<p>[sh_margin margin=”20”]</p>

<h3 id="porqué-usar-parcelable-sobre-serializable">¿Porqué usar Parcelable sobre Serializable?</h3>

<p>La principal razón para implementar Parcelable sobre Serializable es su velocidad de ejecución, se habla de hasta <strong>10x más rápido</strong> trabajar con objetos Parcelable. Si estamos en un entorno móvil, esto se traduce no solo en <strong>mayor rapidez</strong>, sino también en <strong>menor consumo de batería</strong>, algo que nunca debemos obviar a la hora de desarrollar apps.
Como decimos esta gran ventaja en cuanto a velocidad viene con un precio y es que la implementación y sobre todo el mantenimiento de este tipo de objetos es muy tediosa, siendo una tarea muy repetitiva y donde es muy fácil cometer errores.</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="android-autoparcel-al-rescate">Android AutoParcel al rescate</h3>

<p>Para solucionar esto, existe una librería muy interesante, o más que librería deberíamos hablar de <strong>plug-in para Gradle</strong>, que en tiempo de compilación, es capaz de generar el código de serialización y deserialización de nuestros objetos. Al ser en tiempo de compilación, no penaliza en absoluto la ejecución y nos beneficiamos de no tener que lidiar con los tediosos métodos de la interfaz Parcelable. Esta se llama <a href="https://github.com/frankiesardo/auto-parcel">Android AutoParcel</a> y es un port de la librería <a href="https://github.com/google/auto/tree/master/value">Google AutoValue</a>.</p>

<p>Vamos a ver cómo podemos integrar fácilmente este plug-in en nuestros proyectos y cómo usarlo. Lo primero será modificar el fichero raíz <strong>build.gradle</strong>, donde agregaremos en las dependencias la siguiente línea:</p>

<p>[code language=”groovy”]
buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath ‘com.android.tools.build:gradle:0.11.+’
        classpath ‘com.neenbedankt.gradle.plugins:android-apt:+’
    }
}</p>

<p>allprojects {
    repositories {
        mavenCentral()
    }
}
[/code]</p>

<p>Ahora nos vamos al fichero <strong>build.gradle</strong> de la aplicación, lo primero será aplicar el plug-in <strong>android-apt</strong> y luego agregamos en la sección de dependencias del proyecto tanto el procesador que generará el código en tiempo de compilación como la librería con las anotaciones de AutoParcel.</p>

<p>[code language=”groovy”]
apply plugin: ‘android’
apply plugin: ‘android-apt’</p>

<p>android {
    …
}</p>

<p>dependencies {
    compile fileTree(dir: ‘libs’, include: [‘*.jar’])
    compile ‘com.github.frankiesardo:android-auto-value:+’
    apt ‘com.github.frankiesardo:android-auto-value-processor:+’
}
[/code]</p>

<p>Ahora refrescamos el proyecto y vamos a escribir nuestro primer objeto con AutoParcel. Nuestras <strong>clases tendrán que ser abstractas</strong> y <strong>por cada propiedad que queramos que tenga, debemos generar un método abstracto</strong> para obtener su valor.</p>

<p>[code language=”java”]
import android.auto.value.AutoValue;
import android.os.Parcelable;</p>

<p>@AutoValue
public abstract class Foo implements Parcelable {</p>

<p>public abstract String fooString();
   public abstract int fooInteger();</p>

<p>}
[/code]</p>

<p>Solo nos falta una forma para poder construir objetos de tipo Foo, para ello agregamos un método estático con todos los valores e internamente y llamaremos en su interior al constructor del objeto que AutoParcel genera. El orden de los parámetros será el mismo con el que hemos escrito nuestra clase abstracta. Al momento de escribir este código muy probablemente la clase <strong>AutoValue_Foo</strong> aún no exista, debemos compilar para que el generador se ejecute y cree la clase.</p>

<p>[code language=”java”]
import android.auto.value.AutoValue;
import android.os.Parcelable;</p>

<p>@AutoValue
public abstract class Foo implements Parcelable {</p>

<p>public abstract String fooString();
   public abstract int fooInteger();</p>

<p>public static final Foo create(String fooString, int fooInteger) {
      return new AutoValue_Foo(fooString, fooInteger);
   }</p>

<p>}
[/code]</p>

<p>Y con esto ya está todo, de esta forma tan simple podemos ahora generar objetos que utilizar como argumentos o extras para los <em>Fragments _y _Activities</em> que usemos en nuestras aplicaciones, reduciendo la cantidad de código que tenemos que escribir considerablemente y sin caer en malas prácticas acoplando los componentes de nuestra aplicación.</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="más-info">Más info</h3>

<p>Puedes obtener más info y acceder al código en su página en GitHub.</p>

<p>[github repo=”frankiesardo/auto-parcel”]</p>
 <a class="read-more" href="/blog/2014/06/parcelables-con-android-autoparcel/">&raquo;</a>
        </section>
        <footer class="post-meta">
            <img class="author-thumb" src="/assets/images/avatar.jpg" alt="Author image" nopin="nopin" />
            <!-- author -->
            <a href='/author/raycoarana'>Rayco Araña</a>
            <!-- [[tags prefix=" on "]] -->
             
                on 
                
                    
                       <a href='/tag/activity'>Activity</a>,
                       
                
                    
                       <a href='/tag/android'>Android</a>,
                       
                
                    
                       <a href='/tag/autoparcel'>Autoparcel</a>,
                       
                
                    
                       <a href='/tag/autovalue'>Autovalue</a>,
                       
                
                    
                       <a href='/tag/fragment'>Fragment</a>,
                       
                
                    
                       <a href='/tag/parcelable'>Parcelable</a>
                       
                
            
            <time class="post-date" datetime="2014-06-09">09 Jun 2014</time>
        </footer>
    </article>
    
    <article class="post">
        <header class="post-header">
            <h2 class="post-title"><a href="/blog/2014/04/timeline-y-live-cards-primeros-pasos-con-google-glass-iv/">Timeline y Live Cards. Primeros pasos con Google Glass (V)</a></h2>
        </header>
        <section class="post-excerpt">
            <p>Hace mucho que no escribía en el blog, entre otras cosas porque ando un poco liado con un proyecto personal. Además, como ya sabrás Google ha actualizado Google Glass a la versión de firmware XE16, subiendo la versión de Android a 4.4.2, actualizando también el GDK y por consiguiente, nos trae muchos cambios en la API. Esto ha implicado que parte de este artículo ya no tenga sentido, ya que Google ha eliminado la clase TimelineManager y por tanto, ya no es posible publicar en el Timeline tarjetas estáticas.</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="cambios-en-el-gdk">Cambios en el GDK</h3>

<p>Antes de continuar con la última entrega en esta serie de artículos de introducción a Google Glass, toca actualizar los anteriores. En el repositorio Git donde está el código de todos los artículos anteriores, podrás encontrar los proyectos actualizados con estos cambios, no son muchos y la mayoría no son más que cambios de nombres.</p>

<!-- more -->

<ul>
  <li>
    <p><strong>Nuevo permiso para comandos de voz propios.</strong> Si queremos utilizar comandos de voz que están fuera de la lista oficial de comandos, tendrás que añadir el permiso <em><strong>com.google.android.glass.permission.DEVELOPMENT</strong></em> en tu Manifest. Ni que decir tiene, que con este permiso no te permitirán subir la aplicación a MyGlass. Los comandos de voz permitidos están incluidos ahora como constantes en la clase <strong><em>VoiceTriggers.Command</em></strong> y en el tag <strong><em>trigger</em></strong> debemos indicar el comando usando el atributo <strong><em>command</em></strong>
.</p>
  </li>
  <li>
    <p><strong>Clase Card.</strong> Cambia el nombre del método <em>toView()</em> a <em>getView()</em>. Además existe una sobrecarga para la reutilización de vistas cuando se utiliza dentro de un CardScrollView.</p>
  </li>
  <li>
    <p><strong>Clases CardScrollView y CardScrollAdapter.</strong> Hay varios métodos que ya no existen o que ya no se pueden sobrescribir.</p>
  </li>
</ul>

<p>El resto de cambios afectan a API que no hemos visto, como la que ya hemos comentado, la desaparición de la clase <em>TimelineManager</em>. Si quieres ver el resto de cambios, puedes consultar las <a href="https://developers.google.com/glass/release-notes">Release Notes</a> que ha publicado Google.</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="static-cards">Static Cards</h3>

<p>Como decíamos anteriormente, las Static Cards ya no existen como tal. Anteriormente, usando la clase <em>TimelineManager</em> era posible publicar una tarjeta (objetos de tipo Card) directamente al Timeline, en la parte derecha que corresponde al pasado. El problema de esta API es que estas tarjetas no eran muy útiles, ya que el usuario no podía interactuar con ellas. No era posible asociarle un menú con el que poder interactuar y es esta seguramente la principal razón de su eliminación. Por lo tanto una Static Card no será más que una Live Card cuya vista permanece estática, aunque esto siempre será en la parte del futuro. ¿Y para el pasado? A mí esto me huele a próxima integración con la nueva API de Wearables que tenemos en Android y las tarjetas estáticas serán notificaciones.</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="live-cards">Live Cards</h3>

<p>Las Live Cards son por tanto la única forma que tenemos para insertar tarjetas en el Timeline de Google Glass (al menos por ahora). Para crear una tarjeta, basta con construir un objeto de tipo <strong><em>LiveCard</em></strong>, pasando el contexto y un tag con el que identificamos a la tarjeta.</p>

<p>[code language=”java”]
LiveCard liveCard = new LiveCard(this, “simple-card”);
[/code]</p>

<p>Una vez tenemos nuestra tarjeta, necesitamos decirle qué queremos mostrar. Existen dos tipos de Live Cards, en función de la frecuencia de actualización de la interfaz que necesitemos, las creadas a partir de una vista normal para baja frecuencia de actualización o las creadas sobre un SurfaceHolder, para por ejemplo, pintar con OpenGL, cuando se requiera una frecuencia de actualización alta. Es decir, si vamos a modificar el contenido de nuestra Live Card una o dos veces por segundo como mucho, la primera aproximación es la adecuada. Si por contra vamos a crear un compass, realidad aumentada o algo que necesite una frecuencia de 20-30 o más veces por segundo, debemos optar por la segunda opción.</p>

<p>Para las primeras, debemos asignarle una <strong>RemoteView</strong>. Esto ya nos debería sonar, en Android las <strong>RemoteView **se utilizan para cuando queremos crear Widgets y en cierta manera es justo lo que queremos hacer ahora, queremos darle a otra aplicación (el Timeline) una vista para que la muestre desde nuestra aplicación. Hay que tener esto claro para entender por qué no podemos poner cualquier vista en una **RemoteView</strong> y como es además su forma de actualización a través del objeto <strong>RemoveView</strong>, realmente <strong>nos estamos comunicando con otra aplicación</strong>, que vive en otro contexto distinto al de nuestra app.</p>

<p>[code language=”java”]
RemoteViews views = new RemoteViews(context.getPackageName(), 
                                    R.layout.view_of_my_livecard);
liveCard.setViews(views);
[/code]</p>

<p>Para las segundas, como comentamos necesitamos activar el <em>flag</em> de que nos vamos a encargar nosotros directamente del pintado y hacerlo mediante el <em>callback</em> que nos proporciona el <strong><em>SurfaceHolder</em></strong>. A partir de aquí podríamos crear un contexto de OpenGL por ejemplo y a partir de ahí crear lo que queramos. Pero eso ya no forma parte de esta serie de artículos de introducción a Google Glass, ya que lo podemos considerar como un aspecto avanzado y al que aplican las mismas reglas a partir de aquí a cualquier aplicación Android que use un SurfaceHolder.rfaceHolder_**.</p>

<p>[code language=”java”]
liveCard.setDirectRenderingEnabled(true);
liveCard.getSurfaceHolder().addCallback(callback);
[/code]</p>

<p>Una vez tenemos ya configurada nuestra Live Card, solo nos queda publicarla, para ello es tan sencillo como llamar al método <strong><em>publish()</em></strong>. Este método nos pide un parámetro para indicar la forma de publicación, <strong>REVEAL</strong> o <strong>SILENT</strong>. Con REVEAL le estamos indicando al Timeline que debe llevar al usuario a nuestra tarjeta recién publicada. Si por contra utilizamos SILENT, como nos podemos imaginar, la tarjeta se publicará sin <em>molestar</em> al usuario.</p>

<p>Pero… ¿realmente ya está? La verdad es que no. Si ejecutamos el código que hemos ido viendo y lo ejecutamos en una actividad, veremos que al salir de esta y volver al Timeline, nuestra tarjeta no existe. El problema es el ciclo de vida de nuestra aplicación y la tarjeta. Si recordáis del desarrollo de Widgets en Android, era siempre necesario tener un servicio en el que se apoyase el Widget y en el caso de las Live Cards nos ocurre igual, debemos crear un servicio y asociarlo a nuestra <em>LiveCard</em> utilizando el método <strong><em>attach()</em></strong> o creándolo directamente desde el propio servicio y que este gestione explícitamente su ciclo de vida.</p>

<p>[code language=”java”]
liveCard.attach(myService);
liveCard.publish(PublishMode.REVEAL);
[/code]</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="manos-a-la-obra">Manos a la obra</h3>

<p>Vamos a crear un ejemplo completo, vamos a crear un <strong>Voice Trigger con Prompt</strong> el cual lanzará un servicio. En este servicio, con cada Intent recibido, actualizaremos la Live Card para que muestre el texto que ha dictado el usuario. Además, llevaremos al usuario a dicha tarjeta una vez la hemos actualizado. Empezamos!</p>

<p>En primer lugar creamos el layout de nuestra Live Card. Vamos a hacer algo sencillo, simplemente un TextView en el que mostrar el texto.</p>

<p>[code language=”xml”]</p>
<TextView xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/my_card_content" android:layout_width="match_parent" android:layout_height="match_parent" />

<p>[/code]</p>

<p>Ahora vamos a crear el servicio, primero el esqueleto del mismo.</p>

<p>[code language=”java”]
public class Demo4Service extends Service {</p>

<div class="highlighter-rouge"><pre class="highlight"><code>@Override
public IBinder onBind(Intent intent) {
    return null;
}

@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    ...
    return START_STICKY;
}

@Override
public void onDestroy() {
    ...
} } [/code]
</code></pre>
</div>

<p>Ahora en el método <strong><em>onStartCommand()</em></strong> recibiremos cada uno de los Intent que el usuario vaya lanzando, así que lo primero será transformar el texto obtenido desde la lista a una simple String.</p>

<p>[code language=”java”]
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        ArrayList<String> voiceResults = intent.getExtras().getStringArrayList(RecognizerIntent.EXTRA_RESULTS);</String></p>

<div class="highlighter-rouge"><pre class="highlight"><code>    StringBuilder userContent = new StringBuilder();
    for (String voiceToken : voiceResults) {
        userContent.append(voiceToken);
        userContent.append(" ");
    } ... [/code]
</code></pre>
</div>

<p>Una vez tenemos ya la cadena a mostrar, vamos a crear la tarjeta. La tarjeta solo será necesaria crearla si es la primera vez que el usuario lanza el comando desde el inicio del servicio. Si este ya estaba en ejecución, la tarjeta ya existe y solo tendremos que actualizarla. Para esto es importante quedarnos con una instancia siempre de la tarjeta a nivel de servicio.</p>

<p>[code language=”java”]
…
        boolean haveToPublish = false;
        if (mLiveCard == null) {
            mLiveCard = new LiveCard(this, “simple-card”);
            mLiveCard.setAction(PendingIntent.getActivity(this, 0, new Intent(this, MenuActivity.class), 0));
            mRemoteViews = new RemoteViews(getPackageName(), R.layout.view_of_my_livecard);
            haveToPublish = true;
        }
…
[/code]</p>

<p>En el trozo de código anterior podemos ver cómo creamos la tarjeta y cómo le asignamos una acción. <strong>¡Ojo con esto porque es obligatorio!</strong>, si no definimos una acción a nuestra tarjeta, esta no se publicará. <strong>Si nuestra tarjeta no tiene de verdad ninguna función a mostrar</strong> cuando el usuario pulsa sobre ella, debemos lanzar una actividad, que no haga ni muestre nada, pero que reproduzca el <strong>sonido correspondiente para indicar al usuario que no existe acción posible</strong>. Esto es algo en lo que insisto mucho siempre a los desarrolladores, siempre, siempre, siempre hay que dar feedback al usuario de lo que está pasando, para que no se quede dando TAPs al TouchPad para ver si se muestra algo y no saber si es que no hay nada, no funciona o el dispositivo no funciona bien.</p>

<p>También podemos ver en este trozo de código cómo creamos la vista de nuestra tarjeta, que como hemos hablado anteriormente, se trata de una <strong>RemoteView</strong>. También nos guardamos la instancia de la <strong>RemoteView</strong> para poder actualizarla a posteriori.</p>

<p>Lo siguiente será un código que se ejecutará siempre, independientemente de si la tarjeta existía con anterioridad o no y es la actualización de la vista con el texto dictado por el usuario. Para ello utilizamos uno de los métodos soportados por el objeto <strong>RemoteViews</strong> para actualizar el contenido de esa vista remota. Una vez lo hemos actualizado, necesitamos reasignarlo a la Live Card para que esta tenga conocimiento del cambio.</p>

<p>[code language=”java”]
…
        mRemoteViews.setTextViewText(R.id.my_card_content, userContent);
        mLiveCard.setViews(mRemoteViews);
…
[/code]</p>

<p>Ya por último dentro del método <em>onStartCommand()</em> nos falta publicar la tarjeta, si no estaba ya publicada o navegar hacia ella si ya lo estaba. Para ello nos ayudamos del flag que hemos definido anteriormente de la siguiente forma:</p>

<p>[code language=”java”]
…
        if(haveToPublish) {
            mLiveCard.publish(LiveCard.PublishMode.REVEAL);
        } else {
            mLiveCard.navigate();
        }
…
[/code]</p>

<p>Bien, ya tenemos creada nuestra tarjeta, ahora necesitamos implementar el evento onDestroy de nuestro servicio, donde vamos a retirar nuestra tarjeta del Timeline.</p>

<p>[code language=”java”]
    @Override
    public void onDestroy() {
        if (mLiveCard != null &amp;&amp; mLiveCard.isPublished()) {
            mLiveCard.unpublish();
            mLiveCard = null;
        }
        super.onDestroy();
    }
[/code]</p>

<p>Ya lo tenemos todo, ahora solo nos falta configurar el <em>AndroidManifest</em> y el Voice Trigger con su Prompt como ya sabemos. Lo primero el Voice Trigger con el Prompt.</p>

<p>[code language=”xml”]</p>
<trigger keyword="@string/trigger_show_my_card">
    <input prompt="@string/prompt_show_my_card" />
</trigger>
<p>[/code]</p>

<p>Y declaramos el servicio en el <em>AndroidManifest</em>, asociándolo al Voice Trigger.</p>

<p>[code language=”xml”]
…
        <service android:name=".Demo4Service">
            <intent-filter>
                <action android:name="com.google.android.glass.action.VOICE_TRIGGER"></action>
            </intent-filter></service></p>

<div class="highlighter-rouge"><pre class="highlight"><code>        &lt;meta-data android:name="com.google.android.glass.VoiceTrigger"
            android:resource="@xml/show_my_card_trigger" /&gt;
    &lt;/service&gt; ... [/code]
</code></pre>
</div>

<p><strong>Recordad añadir el permiso para poder usar comandos personalizados</strong></p>

<p>[sh_margin margin=”20”]</p>

<h3 id="interactuando-con-nuestra-live-card">Interactuando con nuestra Live Card</h3>

<p>Anteriormente hemos visto cómo añadíamos una acción a nuestra Live Card, algo que es obligatorio, así que para completar nuestra aplicación, debemos implementar ese MenuActivity, el cual deberá ser transparente y que al mostrarse deberá abrir el menú. Además, si el menú se cierra, debe finalizarse y dejar la tarjeta en primer plano. Es todo código que ya hemos hecho en anteriores artículos, pero vamos a repasarlo rápidamente.</p>

<p>Creamos el fichero de menú.</p>

<p>[code language=”xml”]</p>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:id="@+id/one" android:title="One" />
    <item android:id="@+id/two" android:title="Two" />
</menu>
<p>[/code]</p>

<p>Creamos la actividad, en la cual no necesitaremos el método <em>onCreate()</em> ya que esta no va a tener interfaz gráfica. Para asociarle un menú a la actividad, lo hacemos como siempre. Para simplificar, no le vamos a añadir código para cuando se selecciona alguna de las opciones del menú, pero en caso de querer hacer algo, solo tendríamos que añadir el código que corresponda en el <strong>switch</strong>.</p>

<p>[code language=”java”]
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.my_menu, menu);
        return true;
    }</p>

<div class="highlighter-rouge"><pre class="highlight"><code>@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()) {
        default:
            return super.onOptionsItemSelected(item);
    }
} [/code]
</code></pre>
</div>

<p>Ahora para hacer que el menú se muestre al abrir la actividad y que la actividad se finalice cuando el menú se cierre implementamos los siguientes métodos.</p>

<p>[code language=”java”]
    @Override
    public void onAttachedToWindow() {
        super.onAttachedToWindow();
        openOptionsMenu();
    }</p>

<div class="highlighter-rouge"><pre class="highlight"><code>@Override
public void onOptionsMenuClosed(Menu menu) {
    finish();
} [/code]
</code></pre>
</div>

<p>Ya solo nos quedan un par de pequeños detalles para terminar nuestra aplicación y poder ver nuestra Live Card en acción. Lo primero es hacer nuestra actividad transparente, para eso vamos a sobrescribir el tema para esta actividad por uno que haga el fondo transparente y elimine cualquier animación de entrada de la actividad. En nuestro fichero de estilos agregamos el siguiente tema. Esperemos que en un futuro GDK este tema venga incluido por defecto en el sistema.</p>

<p>[code language=”xml”]
    <style name="MenuTheme" parent="@android:style/Theme.DeviceDefault">
        <item name="android:windowBackground">@android:color/transparent</item>
        <item name="android:colorBackgroundCacheHint">@null</item>
        <item name="android:windowIsTranslucent">true</item>
        <item name="android:windowAnimationStyle">@null</item>
    </style>
[/code]</p>

<p>Por último nos queda registrar la actividad en el <em>AndroidManifest</em>, donde le asociaremos el tema que hemos creado.</p>

<p>[code language=”xml”]
        <activity android:name=".MenuActivity" android:theme="@style/MenuTheme"></activity>
[/code]</p>

<p>Ejecutamos el proyecto y decimos “ok glass, show my card”, nos saltará el Prompt y a continuación, nuestra tarjeta.</p>

<p>Y con esto terminamos esta serie de artículos dedicados a Google Glass. Esto es lo básico y que marca diferencia con una aplicación Android, si bien me reservo aún algún tema como la autenticación con cuentas Google y no Google en Glass, pero hay muchas más cosas con las que experimentar ahí fuera y por ahora y hasta que exista un gran cambio de API en Google Glass, creo que es algo ya superado. Como siempre tenéis disponible el código en el repositorio de GitHub de esta serie de artículos bajo la carpeta <strong>4.Timeline</strong>.</p>

<p>[github repo=”raycoarana/google_glass_first_steps”]</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="conclusiones">Conclusiones</h3>

<p>Con la utilización de Google Glass en el día a día vemos que a pesar del gran <strong><em>hype</em></strong> que tiene a su alrededor, no es más que un dispositivo Wearable y como tal, tiene grandes usos específicos, pero a su vez grandes limitaciones en su utilización. Es un complemento ideal para que te guíe por medio de una ciudad que no conoces, pero nada apropiado para leer o interactuar con ellas durante un largo tiempo. Como siempre serán las apps las que hagan de este dispositivo algo útil y básico en nuestro día a día o una mera anécdota en la historia de los gadgets. Así pues, ¡su futuro está en vuestras manos!</p>

<p><em>Happy coding explorers! :-)</em></p>
 <a class="read-more" href="/blog/2014/04/timeline-y-live-cards-primeros-pasos-con-google-glass-iv/">&raquo;</a>
        </section>
        <footer class="post-meta">
            <img class="author-thumb" src="/assets/images/avatar.jpg" alt="Author image" nopin="nopin" />
            <!-- author -->
            <a href='/author/raycoarana'>Rayco Araña</a>
            <!-- [[tags prefix=" on "]] -->
             
                on 
                
                    
                       <a href='/tag/android'>Android</a>,
                       
                
                    
                       <a href='/tag/cards'>Cards</a>,
                       
                
                    
                       <a href='/tag/gdk'>Gdk</a>,
                       
                
                    
                       <a href='/tag/glassware'>Glassware</a>,
                       
                
                    
                       <a href='/tag/google glass'>Google glass</a>,
                       
                
                    
                       <a href='/tag/live card'>Live card</a>,
                       
                
                    
                       <a href='/tag/static card'>Static card</a>,
                       
                
                    
                       <a href='/tag/timeline'>Timeline</a>
                       
                
            
            <time class="post-date" datetime="2014-04-29">29 Apr 2014</time>
        </footer>
    </article>
    
    <article class="post">
        <header class="post-header">
            <h2 class="post-title"><a href="/blog/2014/03/cards-api-primeros-pasos-google-glass-iv/">Cards API. Primeros pasos con Google Glass (IV)</a></h2>
        </header>
        <section class="post-excerpt">
            <p>Hoy vamos a ver cómo crear interfaces gráficas para nuestro Glassware utilizando el concepto de tarjetas o Cards. Como sabéis, en Google Glass no hay botones, no hay forma de interactuar con elementos en la interfaz gráfica, sino que esta se compone de pantallas por las que podemos movernos, pantallas que se denominan tarjetas o Cards. El propio Timeline que se representa en la inferfaz inicial de Google Glass es un conjunto de tarjetas por las que podemos movernos. ¿Cómo podemos crear una interfaz de este estilo? Pues de forma muy fácil utilizando las clases CardScrollView, CardScrollAdapter y Card. ¡Vamos a ello!</p>

<!-- more -->

<p>[sh_margin margin=”20”]</p>

<h3 id="crear-y-configurar-el-proyecto">Crear y configurar el proyecto</h3>

<p>Lo primero que debemos hacer será crear un nuevo proyecto. Para ello te recomiendo que sigas el artículo de <a href="http://raycoarana.com/desarrollo/primeros-pasos-con-google-glass-ii/">Primeros pasos con Google Glass (II)</a>, donde vimos cómo crear y configurar un proyecto en Android Studio para Google Glass.</p>

<p>Una vez hemos creado el proyecto vacío, vamos a crear una actividad donde mostraremos nuestra interfaz de tarjetas. Creamos una clase con nombre <strong><em>CardsActivity</em></strong> y la añadimos al <strong><em>AndroidManifest.xml</em></strong>. Si quieres puedes añadirle un comando de voz para lanzar la aplicación o por simplicidad, puedes configurar el entorno para lanzar la aplicación directamente como ya comentamos en el <a href="http://raycoarana.com/desarrollo/primeros-pasos-con-google-glass-ii/">segundo artículo de esta serie</a>. Recuerda que para poder lanzar la actividad desde el entorno esta tendrá que tener un <em>intent-filter</em> con la acción y categoría por defecto (<strong><em>…action.MAIN</em></strong> y <strong><em>…category.LAUNCHER</em></strong>). En esta ocasión no vamos a generar un layout para esta actividad, sino que usaremos directamente la vista CardScrollView como contenido de la actividad como veremos a continuación.</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="cardscrollview-y-cardscrolladapter">CardScrollView y CardScrollAdapter</h3>

<p>La vista <strong><em>CardScrollView</em></strong> es la encargada de mostrar las tarjetas de forma lineal, permite moverse entre ellas con los gestos de <strong>Swipe hacia izquierda o derecha</strong> y todas las animaciones de aceleración al hacer el gesto de forma rápida para pasar rápido entre las distintas tarjetas. Para ello, el CardScrollView utiliza el mismo patrón que muchas otras vistas en Android, el <strong>patrón Adapter</strong>, para adaptar nuestro modelo al control visual que se muestra en pantalla. De esto se encarga el <strong><em>CardScrollAdapter</em></strong>, al cual el <strong><em>CardScrollView</em></strong> irá llamando para construir las tarjetas a mostrar en cada momento, encargándose por nosotros del ciclo de vida de las mismas.</p>

<p>Vamos a crear nuestra vista y asignarla como contenido de nuestra actividad, para ello en el método <strong><em>onCreate()</em></strong> de nuestra actividad hacemos lo siguiente:</p>

<p>[code language=”java”]
public class CardsActivity extends Activity {</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private CardScrollView mCardScrollView;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    mCardScrollView = new CardScrollView(this);
    
    setContentView(mCardScrollView);
} } [/code]
</code></pre>
</div>

<p>Ya tenemos nuestra vista, pero ahora mismo poco va a mostrar ya que no tiene contenido. Vamos a añadirle algunas tarjetas, para ello vamos a crear y configurar un <strong><em>CardScrollAdapter</em></strong>. Para crear un <strong><em>CardScrollAdapter</em></strong>, tendremos que heredar la clase e implementar algunos métodos. Lo normal sería tener un modelo de datos asociado a cada tarjeta, pero para nuestro ejemplo, vamos a prescindir de ello para simplificar, por lo que solo tendremos que implementar el método <em><strong>getCount()</strong></em> y <em><strong>getView()</strong></em> para indicar el número de tarjetas y la vista de cada una de ellas respectivamente. Vamos a crear cuatro tarjetas, así que el código de nuestro Adapter quedaría algo así, donde delegamos la creación de las vistas en métodos que veremos a continuación.</p>

<p>[code language=”java”]
    CardScrollAdapter mCardScrollAdapter = new CardScrollAdapter() {</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    @Override
    public int getCount() {
        return 4;
    }

    @Override
    public Object getItem(int i) {
        return null;
    }

    @Override
    public View getView(int i, View view, ViewGroup viewGroup) {
        View cardView;
        switch (i) {
            case 0:
                cardView = getFirstCardView();
                break;
            case 1:
                cardView = getSecondCardView();
                break;
            case 2:
                cardView = getThirdCardView();
                break;
            default: //case 3:
                cardView = getFourthCardView();
                break;
        }
        return cardView;
    }

    @Override
    public int findIdPosition(Object o) {
        return 0;
    }

    @Override
    public int findItemPosition(Object o) {
        return 0;
    }
}; [/code]
</code></pre>
</div>

<p>Como habéis visto, el <strong><em>CardScrollAdapter</em></strong>, como cualquier otro Adapter, lo que nos pide son vistas, por lo que podríamos crear cualquier tipo de vista para nuestras tarjetas. Sin embargo, Google ha incluido en el SDK la clase <strong><em>Card</em></strong> que nos <strong>permite crear vistas de forma sencilla</strong>, con el estilo de Glass sin tener que preocuparnos por nada. El que hayamos configurado nuestro Adapter con 4 elementos no es casualidad, vamos a ver las principales configuraciones de tarjetas que podemos crear con esta clase.</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="tarjeta-simple-con-texto">Tarjeta simple con texto</h3>

<p>La primera tarjeta que crearemos será una sencilla que solo contendrá un texto. La clase <strong><em>Card</em></strong> requiere como parámetro el contexto y luego le asignaremos los datos a mostrar por la misma. Cuando hemos acabado, llamamos al método <strong><em>toView()</em></strong> para obtener la vista resultante.</p>

<p>[code language=”java”]
    private View getFirstCardView() {
        Card card = new Card(this);
        card.setText(“Tarjeta simple de texto”);
        return card.toView();
    }
[/code]</p>

<p>El resultado de este código es la siguiente tarjeta:</p>

<p>[caption id=”attachment_285” align=”aligncenter” width=”300”]<a href="http://raycoarana.com/wp-content/uploads/2014/03/tarjeta_texto.png"><img src="http://raycoarana.com/wp-content/uploads/2014/03/tarjeta_texto-300x168.png" alt="Tarjeta simple con texto" /></a> Tarjeta simple con texto[/caption]</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="tarjeta-con-texto-e-imagen-a-la-izquierda">Tarjeta con texto e imagen a la izquierda</h3>

<p>Para añadir una imagen a la izquierda de la tarjeta, solo tendremos que llamar al método <strong><em>addImage()</em></strong> y establecer con <strong><em>setImageLayout()</em></strong> que esta esté alineada a la izquierda.</p>

<p>[code language=”java”]
    private View getSecondCardView() {
        Card card = new Card(this);
        card.setText(“Tarjeta con imagen a la izquierda”);
        card.setImageLayout(Card.ImageLayout.LEFT);
        card.addImage(R.drawable.audi);
        return card.toView();
    }
[/code]</p>

<p>El resultado lo podéis ver a continuación:</p>

<p>[caption id=”attachment_286” align=”aligncenter” width=”300”]<a href="http://raycoarana.com/wp-content/uploads/2014/03/tarjeta_texto_imagen_izq.png"><img src="http://raycoarana.com/wp-content/uploads/2014/03/tarjeta_texto_imagen_izq-300x168.png" alt="Tarjeta con texto e imagen a la izquierda" /></a> Tarjeta con texto e imagen a la izquierda[/caption]</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="tarjeta-con-texto-e-imagen-al-fondo">Tarjeta con texto e imagen al fondo</h3>

<p>Si queremos que la imagen no esté a la izquierda sino que esté de fondo de la tarjeta, simplemente cambiamos el ImageLayout de la misma. Esto creará un ligero degradado a negro tras el texto para ganar contraste sobre la imagen.</p>

<p>[code language=”java”]
    private View getThirdCardView() {
        Card card = new Card(this);
        card.setText(“Tarjeta con imagen al fondo”);
        card.setImageLayout(Card.ImageLayout.FULL);
        card.addImage(R.drawable.opel);
        return card.toView();
    }
[/code]</p>

<p>La tarjeta resultante es la siguiente:</p>

<p>[caption id=”attachment_287” align=”aligncenter” width=”300”]<a href="http://raycoarana.com/wp-content/uploads/2014/03/tarjeta_texto_imagen_fondo.png"><img src="http://raycoarana.com/wp-content/uploads/2014/03/tarjeta_texto_imagen_fondo-300x168.png" alt="Tarjeta con imagen de fondo" /></a> Tarjeta con imagen de fondo[/caption]</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="tarjeta-con-texto-nota-al-pie-y-varias-imágenes-a-la-izquierda">Tarjeta con texto, nota al pie y varias imágenes a la izquierda</h3>

<p>Podemos agregar varias imágenes, creándonos un mosaico con ellas. También podremos acompañar el texto principal con un texto al pie de la tarjeta.</p>

<p>[code language=”java”]
    private View getFourthCardView() {
        Card card = new Card(this);
        card.setText(“Tarjeta con texto al pie y varias imagenes”);
        card.setFootnote(“Texto pie de página”);
        card.setImageLayout(Card.ImageLayout.LEFT);
        card.addImage(R.drawable.audi);
        card.addImage(R.drawable.opel);
        return card.toView();
    }
[/code]</p>

<p>El resultado es la siguiente tarjeta:</p>

<p>[caption id=”attachment_288” align=”aligncenter” width=”300”]<a href="http://raycoarana.com/wp-content/uploads/2014/03/tarjeta_multiples_img.png"><img src="http://raycoarana.com/wp-content/uploads/2014/03/tarjeta_multiples_img-300x168.png" alt="Tarjeta con múltiples imágenes y pie" /></a> Tarjeta con múltiples imágenes y pie[/caption]</p>

<p>Ahora que ya tenemos nuestro Adapter con sus vistas, nos falta asignarlo al <strong><em>CardScrollView</em></strong> y activar este. Para ello añadimos estas líneas en el método <strong><em>onCreate()</em></strong> de la actividad.</p>

<p>[code language=”java”]
…
mCardScrollView.setAdapter(mCardScrollAdapter);
mCardScrollView.activate();
…
[/code]</p>

<p>Con esto si lanzamos la aplicación veremos la interfaz de tarjetas con cada una de ellas. Pero, ¿cómo podemos interactuar con ellas? No podemos poner un botón, implementar el OnClickListener no servirá de nada. ¿Entonces? ¿Cómo podemos darle opciones al usuario para realizar acciones sobre cada tarjeta?</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="interactuando-con-una-tarjeta">Interactuando con una tarjeta</h3>

<p>Para interactuar con una tarjeta, debemos asignar un <strong><em>OnItemClickListener</em></strong> al <strong><em>CardScrollView</em></strong>. Cada vez que el usuario haga <em>TAP</em>, la vista nos notificará con la información relativa a la tarjeta sobre la que se ha realizado la pulsación en el TouchPad. En el método <strong><em>onCreate()</em></strong> de nuestra actividad, añadimos la siguiente línea:</p>

<p>[code language=”java”]
…
mCardScrollView.setOnItemClickListener(this);
…
[/code]</p>

<p>Ahora nos queda hacer que nuestra actividad implemente esa interfaz <strong><em>OnItemClickListener</em></strong> y añadir el método <strong><em>OnItemClick()</em></strong>.</p>

<p>[code language=”java”]
…
public class CardsActivity extends Activity implements AdapterView.OnItemClickListener {</p>

<div class="highlighter-rouge"><pre class="highlight"><code>...

@Override
public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {

} } [/code]
</code></pre>
</div>

<p>Bien ahora que ya somos notificados sobre la pulsación sobre una tarjeta, ¿cómo podemos mostrar al usuario operaciones que hacer sobre estos elementos que está viendo? Pues haciendo uso de los menús de Android. En Google Glass, los menús se comportan de manera distinta, mostrándose cada entrada de menú a pantalla completa como tarjetas sobre las que el usuario puede moverse (adivinad qué vista utilizará el sistema operativo para implementar esto). La manera de implementarlo por tanto es muy conocida por cualquier desarrollador Android, pero vamos a repasarla.</p>

<p>Lo primero será crearnos la definición de nuestro menú, creamos un fichero xml en <strong><em>menu/activity_cards.xml</em></strong>. Los iconos los tenéis disponibles en el repositorio junto con el resto del código.</p>

<p>[code language=”xml”]</p>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:id="@+id/menu_read_aloud" android:icon="@drawable/ic_read_aloud" android:title="@string/menu_read_aloud" />

    <item android:id="@+id/menu_share" android:icon="@drawable/ic_share" android:title="@string/menu_share" />

    <item android:id="@+id/menu_close" android:icon="@drawable/ic_close" android:title="@string/menu_close" />

</menu>
<p>[/code]</p>

<p>Una vez tenemos nuestro menú, vamos a incorporarlo a la actividad. Para ello implementamos los métodos <strong><em>onCreateOptionsMenu()</em></strong> y <strong><em>onOptionsItemSelected()</em></strong> para crear el menú cuando sea necesario y realizar acciones cuando se seleccione un elemento del menú. Si quisieramos personalizar el menú en función del elemento sobre el que se hace la selección, podemos implementar el método <strong><em>onPrepareOptionsMenu()</em></strong> y ocultar/mostrar aquellos elementos que nos interese.</p>

<p>[code language=”java”]
…</p>

<div class="highlighter-rouge"><pre class="highlight"><code>@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.activity_cards, menu);
    return true;
}

@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()) {
        case R.id.menu_read_aloud:
            onMenuReadAloud();
            break;
        case R.id.menu_share:
            onMenuShare();
            break;
        case R.id.menu_close:
            onMenuClose();
            break;
        default:
            return super.onOptionsItemSelected(item);
    }
    return true;
}
</code></pre>
</div>

<p>…
[/code]</p>

<p>Ya tenemos muestro menú montado, solo nos falta relacionar el <strong><em>onItemClick</em></strong> del <strong><em>CardScrollView</em></strong> con la apertura del menú y escribir código para cada una de las acciones. Lo primero es tan sencillo como esto:</p>

<p>[code language=”java”]
    @Override
    public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
        this.openOptionsMenu();
    }
[/code]</p>

<p>Pero vamos a complicar un poco el caso, por ejemplo no queremos que para el primer elemento del <strong><em>CardScrollView</em></strong> se muestre un menú. ¿Qué deberíamos hacer? Pues por un lado evitar llamar al método <strong><em>openOptionsMenu()</em></strong> cuando el usuario haga TAP sobre el primer elemento y muy importante, darle <strong>feedback al usuario de que en ese elemento no hay acciones</strong> posibles a realizar. Para esto segundo haremos uso del <strong><em>AudioManager</em></strong> y los sonidos del sistema, que específicamente en Glass están representados por constantes de la clase <strong><em>Sounds</em></strong>, en concreto la constante <em>DISALLOWED</em>. De la misma forma, para darle feedback al usuario de la apertura del menú, haremos lo mismo pero con la constante <em>TAP</em>.</p>

<p>Lo primero, obtener una instancia al <strong><em>AudioManager</em></strong> en el método <strong><em>onCreate()</em></strong>.</p>

<p>[code language=”java”]
    private AudioManager mAudioManager;</p>

<div class="highlighter-rouge"><pre class="highlight"><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
    ... [/code]
</code></pre>
</div>

<p>Ahora en el método <strong><em>onItemClick()</em></strong> hacemos lo siguiente:</p>

<p>[code language=”java”]
    @Override
    public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
        if (position == 0) {
            mAudioManager.playSoundEffect(Sounds.DISALLOWED);
        } else {
            mAudioManager.playSoundEffect(Sounds.TAP);
            this.openOptionsMenu();
        }
    }
[/code]</p>

<p>Ya tenemos la funcionalidad que queríamos, ahora el primer elemento no muestra el menú y da feedback al usuario de ello. Vamos ahora a darle funcionalidad a las acciones que teníamos. No vamos a implementarlas de verdad para no extendernos demasiado, solo vamos mostrar en el log del sistema que se han ejecutado.</p>

<p>[code language=”java”]
    private void onMenuReadAloud() {
        Log.i(“DEMO3”, “onMenuReadAloud()”);
    }</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private void onMenuShare() {
    Log.i("DEMO3", "onMenuShare()");
}

private void onMenuClose() {
    Log.i("DEMO3", "onMenuClose()");
} [/code]
</code></pre>
</div>

<p>Y con esto lo tenemos todo, al ejecutar la aplicación y hacer TAP sobre una de las tarjetas con menú, se nos mostrará dándonos la opción a seleccionar la acción que queremos realizar.</p>

<p>[gallery link=”file” ids=”299,300,298”]</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="buenas-prácticas">Buenas prácticas</h3>

<p>Por último vamos a comentar algunas buenas prácticas que envuelven a las interfaces en general de Googlas Glass y que tienen que ver con estos elementos que hemos visto hoy. Lo primero es la recomendación de siempre utilizar un <strong><em>CardScrollView</em></strong> en nuestras interfaces, aunque solo vayamos a mostrar una sola tarjeta. <strong><em>CardScrollView</em></strong> tiene esos <strong>efectos de rebote animados</strong> cuando el usuario llega al final, dándole un feedback muy importante de la no existencia de más elementos. Así pues, a menos que vayamos a utilizar el Swipe izquierda o derecha para otra cosa, hagamos uso del <strong><em>CardScrollView</em></strong>.</p>

<p>Otra buena práctica muy relacionada con ese feedback es informar al usuario de si su <strong>acción sobre el TouchPad ha sido reconocida o no</strong> mediante sonidos, como hemos podido ver en el código ejemplo. Debemos informar al usuario de qué ocurre cuando hace TAP, reproduciendo el sonido adecuado si no hay acción disponible.</p>

<p>Y hasta aquí hemos llegado en este artículo, como siempre tenéis disponible el código en el respositorio de GitHub de esta serie de artículos bajo la carpeta <strong>3.CardAPI</strong>.</p>

<p>[github repo=”raycoarana/google_glass_first_steps”]</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="continuará">Continuará…</h3>

<p>Ahora que ya sabemos como manejar las tarjetas y mostrar acciones sobre ellas, vamos a ver cómo podemos trabajar con el Timeline, veremos cómo podemos crear tarjetas estáticas, tarjetas dináminas e incorporarlas en el Timeline, pudiendo el usuario interactuar con ellas sin la necesidad de abrir nuestra aplicación.</p>
 <a class="read-more" href="/blog/2014/03/cards-api-primeros-pasos-google-glass-iv/">&raquo;</a>
        </section>
        <footer class="post-meta">
            <img class="author-thumb" src="/assets/images/avatar.jpg" alt="Author image" nopin="nopin" />
            <!-- author -->
            <a href='/author/raycoarana'>Rayco Araña</a>
            <!-- [[tags prefix=" on "]] -->
             
                on 
                
                    
                       <a href='/tag/android'>Android</a>,
                       
                
                    
                       <a href='/tag/android studio'>Android studio</a>,
                       
                
                    
                       <a href='/tag/card'>Card</a>,
                       
                
                    
                       <a href='/tag/gdk'>Gdk</a>,
                       
                
                    
                       <a href='/tag/glassware'>Glassware</a>,
                       
                
                    
                       <a href='/tag/google glass'>Google glass</a>
                       
                
            
            <time class="post-date" datetime="2014-03-31">31 Mar 2014</time>
        </footer>
    </article>
    

    <!-- Previous/next page links - displayed on every page -->
    
        <nav class="pagination" role="pagination">
    
        
            <a class="newer-posts" href="/" title="Previous Page">&laquo; Newer Posts</a>
        
    
    <span class="page-number"> Page 2 of 4 </span>
     
        <a class="older-posts" href="/page3/" title="Next Page">Older Posts &raquo;</a>
     
</nav>
    


</main>


        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/">raycoarana</a> &copy; 2018</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/biomadeira/jasper">Jasper</a></section>
        </footer>
    </div>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="/assets/js/index.js"></script>

    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-48361320-1', 'auto');
	    ga('send', 'pageview');

     </script>   
</body>
</html>
