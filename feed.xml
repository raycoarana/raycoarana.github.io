<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>raycoarana - Articles</title>
    <description>My coding adventures and other random stuff</description>
    <link>
    http://raycoarana.com/</link>
    
      
      <item>
        <title>Concurrency with Promise Style. DroidCon 2015</title>
        
          <description>&lt;p&gt;Os dejo por aquí la presentación de mi charla de hoy en la DroidCon Spain 2015 dónde hablamos del patrón Promise, como implementarlo con jDeferred y como podemos beneficiarnos de su uso.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://speakerd.s3.amazonaws.com/presentations/ef9ad55c34fe4a68b961eb0a214f34ce/Concurrency-with-Promise-Style.pdf&quot;&gt;&lt;strong&gt;Descargar&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;script async=&quot;&quot; class=&quot;speakerdeck-embed&quot; data-id=&quot;ef9ad55c34fe4a68b961eb0a214f34ce&quot; data-ratio=&quot;1.77777777777778&quot; src=&quot;//speakerdeck.com/assets/embed.js&quot;&gt;&lt;/script&gt;

</description>
        
        <pubDate>Sat, 25 Apr 2015 17:25:02 +0200</pubDate>
        <link>
        http://raycoarana.com//blog/2015/04/concurrency-with-promise-style-droidcon-2015/</link>
        <guid isPermaLink="true">http://raycoarana.com//blog/2015/04/concurrency-with-promise-style-droidcon-2015/</guid>
      </item>
      
    
      
      <item>
        <title>Baindo, un MVVM diferente para Android</title>
        
          <description>&lt;p&gt;Hoy os vengo a presentar algo en lo que llevo un tiempo trabajando, &lt;strong&gt;Baindo&lt;/strong&gt;, un framework para aplicar &lt;strong&gt;MVVM en aplicaciones Android&lt;/strong&gt;, del que quiero mostraros un &lt;em&gt;Sneak Peek&lt;/em&gt; del estado actual.
¿Por qué otro framework MVVM si existen miles? La respuesta a esta pregunta está en las ideas base que inspiran Baindo:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Evitar el uso de cualquier tipo de Reflection.&lt;/li&gt;
  &lt;li&gt;Sintaxis cómoda en código Java. Nada de Custom Views o Custom Attributes en nuestros layouts.&lt;/li&gt;
  &lt;li&gt;ViewModels sencillos y con ninguna dependencia con Android.&lt;/li&gt;
  &lt;li&gt;Maximizar el rendimiento del hilo de UI. Comandos y eventos de modificación de las propiedades se ejecutan en Background.&lt;/li&gt;
  &lt;li&gt;Actualización de UI desde cualquier hilo a través de las propiedades del ViewModel. Olvidate de tener que usar AsyncTask, Handlers o similares para hacer cambios en la UI.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pinta bien, ¿no? ;-). Pues además será OpenSource y estará disponible en GitHub muy pronto. Veamos que pinta tiene.&lt;/p&gt;

</description>
        
        <pubDate>Tue, 20 Jan 2015 22:59:40 +0100</pubDate>
        <link>
        http://raycoarana.com//blog/2015/01/baindo-un-mvvm-diferente-para-android/</link>
        <guid isPermaLink="true">http://raycoarana.com//blog/2015/01/baindo-un-mvvm-diferente-para-android/</guid>
      </item>
      
    
      
      <item>
        <title>RoboRouter, mi primera librería OpenSource</title>
        
          <description>&lt;p&gt;Hace tiempo que no escribo nada en el Blog, pero hoy tengo el orgullo de presentar mi primera librería &lt;em&gt;OpenSource&lt;/em&gt;: RoboRouter. Es para Android y disponible a través de &lt;strong&gt;Maven/Gradle&lt;/strong&gt;.&lt;/p&gt;

</description>
        
        <pubDate>Mon, 03 Nov 2014 23:17:07 +0100</pubDate>
        <link>
        http://raycoarana.com//blog/2014/11/roborouter/</link>
        <guid isPermaLink="true">http://raycoarana.com//blog/2014/11/roborouter/</guid>
      </item>
      
    
      
      <item>
        <title>Full text search contra otras formas de búsqueda</title>
        
          <description>&lt;p&gt;Algo muy común en cualquier aplicación Android es el añadir la posibilidad de realizar búsquedas sobre un ListView. Dado que para mostrar los datos sobre un ListView probablemente ya hemos realizado una consulta a la base de datos SQLite donde estos residen, podemos creer que lo mejor es filtrar los datos que ya tenemos cargados en memoria. De esta forma no pagamos de nuevo el precio del acceso a la base de datos que está en disco y es lenta; ni tampoco tenemos que volver a crear los objetos a partir del Cursor que esta nos devuelve. Pero, ¿hemos pensado bien el coste de buscar texto sobre los datos cargados en memoria? ¿Es esto mejor que un acceso a disco? ¿Escala?&lt;/p&gt;

</description>
        
        <pubDate>Sun, 07 Sep 2014 22:28:14 +0200</pubDate>
        <link>
        http://raycoarana.com//blog/2014/09/full-text-search-contra-formas-busqueda/</link>
        <guid isPermaLink="true">http://raycoarana.com//blog/2014/09/full-text-search-contra-formas-busqueda/</guid>
      </item>
      
    
      
      <item>
        <title>Patrón Promise con jdeferred</title>
        
          <description>&lt;p&gt;El patrón Promise es un patrón que trata de simplificar la estructura de nuestro código cuando trabajamos con operaciones asíncronas, algo que está a la orden del día en cualquier aplicación con interfaz gráfica, pero también importante en servicios que tienen distintas dependencias para realizar su trabajo y este puede realizarse en paralelo.&lt;/p&gt;

&lt;p&gt;En primer lugar vamos a plantear el problema que trata de resolverse y cómo lo simplificamos con este patrón y en concreto con la librería &lt;strong&gt;jdeferred&lt;/strong&gt;. Luego veremos el caso de particular de Android y el soporte específico que nos ofrece &lt;strong&gt;jdeferred&lt;/strong&gt; que nos simplifican aún más el trabajo.&lt;/p&gt;

</description>
        
        <pubDate>Fri, 08 Aug 2014 00:02:48 +0200</pubDate>
        <link>
        http://raycoarana.com//blog/2014/08/patron-promise-con-jdeferred/</link>
        <guid isPermaLink="true">http://raycoarana.com//blog/2014/08/patron-promise-con-jdeferred/</guid>
      </item>
      
    
      
      <item>
        <title>Prototipado de apps con WireframeSketcher</title>
        
          <description>&lt;p&gt;Aunque este es un blog fundamentalmente de desarrollo, hoy quería comentar un poco algo que nos toca siempre al comenzar una aplicación: la conceptualización. En el desarrollo móvil no es ningún secreto que tenemos &lt;strong&gt;el problema del tamaño de la pantalla&lt;/strong&gt; -a pesar de los pseudo tablets que tenemos ahora por teléfonos-. A la hora de conceptualizar la aplicación, es fundamental utilizar una &lt;strong&gt;herramienta que nos permita de forma rápida poder organizar la información&lt;/strong&gt; y cómo se comportará nuestra app.&lt;/p&gt;

&lt;p&gt;Desde hace un tiempo he estado buscando la mejor herramienta para esta labor. Algo fundamental que debe tener una herramienta de este tipo es que &lt;strong&gt;respete las proporciones de los componentes nativos&lt;/strong&gt; de la plataforma. Sin esto, conceptualizar una pantalla es un disparate, ya que estamos organizando la información en base a una premisa que puede ser falsa y a la hora de llevarla a la práctica, podemos ver que las cosas no nos caben -o nos sobra espacio-. En esta búsqueda me he topado con &lt;strong&gt;WireframeSketcher&lt;/strong&gt;, una herramienta la mar de interesante, basada en Eclipse y con todos los elementos nativos de Android 4.X -también tiene los de iOS y Windows Phone entre otros-. Vamos a ver las principales características de esta herramienta.&lt;/p&gt;

</description>
        
        <pubDate>Thu, 19 Jun 2014 10:59:16 +0200</pubDate>
        <link>
        http://raycoarana.com//blog/2014/06/prototipado-de-apps-con-wireframesketcher/</link>
        <guid isPermaLink="true">http://raycoarana.com//blog/2014/06/prototipado-de-apps-con-wireframesketcher/</guid>
      </item>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  </channel>
</rss>
