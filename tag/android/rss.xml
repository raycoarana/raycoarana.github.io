<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>raycoarana.com</title>
   
   <link>http://raycoarana.com/</link>
   <description>My coding adventures and other random stuff</description>
   <language>en-uk</language>
   <managingEditor> Rayco Araña</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Concurrency with Promise Style. DroidCon 2015</title>
	  <link>//blog/2015/04/concurrency-with-promise-style-droidcon-2015/</link>
	  <author>Rayco Araña</author>
	  <pubDate>2015-04-25T17:25:02+02:00</pubDate>
	  <guid>//blog/2015/04/concurrency-with-promise-style-droidcon-2015/</guid>
	  <description><![CDATA[
	     <p>Os dejo por aquí la presentación de mi charla de hoy en la DroidCon Spain 2015 dónde hablamos del patrón Promise, como implementarlo con jDeferred y como podemos beneficiarnos de su uso.</p>

<p><a href="https://speakerd.s3.amazonaws.com/presentations/ef9ad55c34fe4a68b961eb0a214f34ce/Concurrency-with-Promise-Style.pdf"><strong>Descargar</strong></a></p>

<script async="" class="speakerdeck-embed" data-id="ef9ad55c34fe4a68b961eb0a214f34ce" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>


	  ]]></description>
	</item>

	<item>
	  <title>Baindo, un MVVM diferente para Android</title>
	  <link>//blog/2015/01/baindo-un-mvvm-diferente-para-android/</link>
	  <author>Rayco Araña</author>
	  <pubDate>2015-01-20T22:59:40+01:00</pubDate>
	  <guid>//blog/2015/01/baindo-un-mvvm-diferente-para-android/</guid>
	  <description><![CDATA[
	     <p>Hoy os vengo a presentar algo en lo que llevo un tiempo trabajando, <strong>Baindo</strong>, un framework para aplicar <strong>MVVM en aplicaciones Android</strong>, del que quiero mostraros un <em>Sneak Peek</em> del estado actual.
¿Por qué otro framework MVVM si existen miles? La respuesta a esta pregunta está en las ideas base que inspiran Baindo:</p>

<ul>
  <li>Evitar el uso de cualquier tipo de Reflection.</li>
  <li>Sintaxis cómoda en código Java. Nada de Custom Views o Custom Attributes en nuestros layouts.</li>
  <li>ViewModels sencillos y con ninguna dependencia con Android.</li>
  <li>Maximizar el rendimiento del hilo de UI. Comandos y eventos de modificación de las propiedades se ejecutan en Background.</li>
  <li>Actualización de UI desde cualquier hilo a través de las propiedades del ViewModel. Olvidate de tener que usar AsyncTask, Handlers o similares para hacer cambios en la UI.</li>
</ul>

<p>Pinta bien, ¿no? ;-). Pues además será OpenSource y estará disponible en GitHub muy pronto. Veamos que pinta tiene.</p>

<!--more-->

<h3 id="un-ejemplo-sencillo">Un ejemplo sencillo</h3>

<p>Vamos a hacer un ejemplo sencillo de como seria su uso. Hagamos un simple hola mundo con un Button y un TextView que al pulsar dicho botón, nos muestre el mensaje <em>“HelloWorld!”</em> en el TextView.</p>

<p>Lo primero es hacer el layout de la vista.</p>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="nt">&lt;LinearLayout</span> <span class="na">xmlns:android=</span><span class="s">"http://schemas.android.com/apk/res/android"</span>
    <span class="na">android:orientation=</span><span class="s">"vertical"</span>
    <span class="na">android:layout_width=</span><span class="s">"match_parent"</span>
    <span class="na">android:layout_height=</span><span class="s">"match_parent"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;TextView</span>
        <span class="na">android:id=</span><span class="s">"@+id/message"</span>
        <span class="na">android:layout_width=</span><span class="s">"match_parent"</span>
        <span class="na">android:layout_height=</span><span class="s">"wrap_content"</span> <span class="nt">/&gt;</span>

    <span class="nt">&lt;Button</span>
        <span class="na">android:id=</span><span class="s">"@+id/button"</span>
        <span class="na">android:layout_width=</span><span class="s">"match_parent"</span>
        <span class="na">android:layout_height=</span><span class="s">"wrap_content"</span>
        <span class="na">android:text=</span><span class="s">"Tap me!"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/LinearLayout&gt;</span>
</code></pre>
</div>

<p>Ahora creamos el ViewModel para nuestro ejemplo, tenemos una acción a ejecutar, luego pondremos un comando y una propiedad de tipo CharSequence a la que asignar el valor <strong>“HelloWorld!”</strong>.
Creamos la propiedad como un atributo público de tipo <code class="highlighter-rouge">Property&lt;CharSequence&gt;</code>, que llamaremos <code class="highlighter-rouge">Message</code>, al cual le asignamos una instancia del mismo tipo.
A continuación el comando como un atributo público de tipo <code class="highlighter-rouge">Command</code>, que llamamos <code class="highlighter-rouge">SayHelloCommand</code>, creamos una clase anónima que le asignamos a dicho atributo y en él llamamos al método <code class="highlighter-rouge">setValue()</code> de la propiedad <code class="highlighter-rouge">Message</code>.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ViewModel</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Property</span><span class="o">&lt;</span><span class="n">CharSequence</span><span class="o">&gt;</span> <span class="n">Message</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Property</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Command</span> <span class="n">SayHelloCommand</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Command</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">Message</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="s">"HelloWorld!"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">};</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Sencillo, limpio y fácil de probar.</p>

<p>A continuación creamos un <code class="highlighter-rouge">Activity</code> que vamos hacer que herede de <code class="highlighter-rouge">BaindoActivity</code>. <strong>Baindo ofrece una serie de Activities, Fragments y Renderers</strong> (utiliza la librería de <a href="https://github.com/pedrovgs/Renderers">Renderers</a> para introducir el binding en Adapters) a partir de las cuales crear nuestras vistas. También ofrece un sencillo mecanismo para crear o dar soporte a Baindo en nuestros propios Activities y Fragments base, con muy pocas líneas. Ya os contaré más acerca de como hacer esto.</p>

<p>En este <code class="highlighter-rouge">Activity</code>, una vez le hemos asignado el layout, llamaremos a un método <code class="highlighter-rouge">bindViews()</code> justo después del <code class="highlighter-rouge">setContentView()</code>.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClickActivity</span> <span class="kd">extends</span> <span class="n">BaindoActivity</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">ViewModel</span> <span class="n">mViewModel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ViewModel</span><span class="o">();</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
        <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_click</span><span class="o">);</span>

        <span class="n">bindViews</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Por último, vamos a implementar el método <em>bindViews()</em>, en el vamos a hacer el bind entre el <code class="highlighter-rouge">Button</code> del layout y el comando <code class="highlighter-rouge">SayHelloCommand</code>. Y luego entre el <code class="highlighter-rouge">TextView</code> y la propiedad <code class="highlighter-rouge">Message</code>. Cuando hacemos un bind a una propiedad debemos establecer la <em>dirección</em> del bind. Este puede ser unidireccional hacia el ViewModel (<code class="highlighter-rouge">writeOnly</code>), hacia la vista, (<code class="highlighter-rouge">readOnly</code>) o bidireccional (<code class="highlighter-rouge">readWrite</code>).</p>

<p>Como ya iremos viendo según avancemos sobre los diferentes bindings que permite Baindo, no todos permiten ambas direcciones, por ejemplo un control <code class="highlighter-rouge">ProgressBar</code> solo permite el modo readOnly. Un <code class="highlighter-rouge">SeekBar</code>, sin embargo, permite cualquiera de ellos.</p>

<p>En este caso vamos a ponerlo en modo readOnly, ya que solo queremos que la vista muestre lo que tiene el ViewModel sin modificarlo en ningún caso.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">bindViews</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">bind</span><span class="o">().</span><span class="na">text</span><span class="o">()</span>
              <span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">message</span><span class="o">)</span>
              <span class="o">.</span><span class="na">to</span><span class="o">(</span><span class="n">mViewModel</span><span class="o">.</span><span class="na">Message</span><span class="o">).</span><span class="na">readOnly</span><span class="o">();</span>
        <span class="n">bind</span><span class="o">().</span><span class="na">click</span><span class="o">()</span>
              <span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">button</span><span class="o">)</span>
              <span class="o">.</span><span class="na">to</span><span class="o">(</span><span class="n">mViewModel</span><span class="o">.</span><span class="na">SayHelloCommand</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre>
</div>

<p>Y ya lo tenemos, si ejecutamos la aplicación (acordaos de registrar la actividad en el manifest), tenemos lo que esperamos, el mensaje se muestra en el <code class="highlighter-rouge">TextView</code> una vez pulsamos el botón.</p>

<p>El código que hemos escrito en el comando se ejecuta en un hilo separado, un hilo que llamaremos <strong>hilo del ViewModel</strong>, así pues tendremos en nuestra app <strong>un hilo de UI y tantos hilos como Activities/Fragments tengamos en pantalla</strong>. Estos hilos son avisados cuando se producen cambios en la UI y notifican cambios en el ViewModel al hilo de UI.</p>

<h3 id="puedo-hacer-cualquier-cosa-en-un-hilo-de-viewmodel">¿Puedo hacer cualquier cosa en un hilo de ViewModel?</h3>
<p>Pues si y no, depende de tu ViewModel y tu vista, hay que tener en cuenta que si bien no vas a bloquear nunca la UI, si que puedes producir el efecto de que al pulsar un botón no pasa nada hasta pasado un tiempo. <strong>Si el hilo del ViewModel está ocupado, no puede atender a ese nuevo evento de UI</strong>, los cuales serán atendidos una vez el hilo del ViewModel quede liberado. Lo ideal del hilo de ViewModel es hacer esos pequeños cálculos previos a pintar nuestros modelos. No es un proceso de negocio, sino un proceso de  preparación para ser mostrado en UI como manejo de cadenas, pequeñas operaciones, coordinar operaciones en background, etc.</p>

<p>Con este esquema <strong>conseguimos la mejor respuesta de la UI al usuario</strong>. Adiós parones, bajadas de framerate en animaciones, etc., gracias a Baindo podemos olvidarnos de todo esto. Estad atentos al blog, <strong>muy pronto publicaré la primera alpha</strong> para que podáis trastear con ella, hasta entonces, sed pacientes!!</p>

	  ]]></description>
	</item>

	<item>
	  <title>RoboRouter, mi primera librería OpenSource</title>
	  <link>//blog/2014/11/roborouter/</link>
	  <author>Rayco Araña</author>
	  <pubDate>2014-11-03T23:17:07+01:00</pubDate>
	  <guid>//blog/2014/11/roborouter/</guid>
	  <description><![CDATA[
	     <p>Hace tiempo que no escribo nada en el Blog, pero hoy tengo el orgullo de presentar mi primera librería <em>OpenSource</em>: RoboRouter. Es para Android y disponible a través de <strong>Maven/Gradle</strong>.
<!--more--></p>

<h3 id="qué-es-roborouter">¿Qué es RoboRouter?</h3>
<p>RoboRouter es un pequeña librería <em>-de apenas dos clases-</em> que permite mediante la activación/desactivación de componentes <strong>manejar el punto de arranque de nuestra aplicación</strong> cuando esta tiene una pantalla de inicio de sesión y/o un asistente de bienvenida o tutorial inicial. Cosas que es muestran escasamente una vez en la vida de la aplicación en el móvil de un usuario y que no debería <em>ensuciar</em> el código de la actividad principal con la que arrancamos la aplicación normalmente. RoboRouter permite gestionar este tipo de escenarios de una forma <strong>muy fácil y sin apenas escribir código</strong>.</p>

<p>Pasaos por <a href="https://github.com/raycoarana/roborouter">GitHub</a> y mirad como funciona, descargad el proyecto de ejemplo y jugad con él. Cualquier sugerencia será bienvenida.</p>

<p>[github repo=”raycoarana/roborouter”]</p>

	  ]]></description>
	</item>

	<item>
	  <title>Full text search contra otras formas de búsqueda</title>
	  <link>//blog/2014/09/full-text-search-contra-formas-busqueda/</link>
	  <author>Rayco Araña</author>
	  <pubDate>2014-09-07T22:28:14+02:00</pubDate>
	  <guid>//blog/2014/09/full-text-search-contra-formas-busqueda/</guid>
	  <description><![CDATA[
	     <p>Algo muy común en cualquier aplicación Android es el añadir la posibilidad de realizar búsquedas sobre un ListView. Dado que para mostrar los datos sobre un ListView probablemente ya hemos realizado una consulta a la base de datos SQLite donde estos residen, podemos creer que lo mejor es filtrar los datos que ya tenemos cargados en memoria. De esta forma no pagamos de nuevo el precio del acceso a la base de datos que está en disco y es lenta; ni tampoco tenemos que volver a crear los objetos a partir del Cursor que esta nos devuelve. Pero, ¿hemos pensado bien el coste de buscar texto sobre los datos cargados en memoria? ¿Es esto mejor que un acceso a disco? ¿Escala?
<!--more--></p>

<h3 id="la-magnitud-del-problema">La magnitud del problema</h3>
<p>Al implementar el filtrado en memoria y optando por una solución sencilla y viable para su desarrollo, descartando el crear grandes estructuras de datos, es tan sencillo como implementar un pequeño bucle que recorra cada elemento y por cada uno realice la búsqueda del texto. Por cada elemento haremos uno o varios contains para buscar la cadena que quiere el usuario sobre el elemento. Esto nos lleva a un problema de O(n*m), dónde n es el número de elementos sobre los que buscar y m es el tamaño de la cadena de texto sobre la que buscar en cada elemento. Esto a priori ya nos da una señal de cómo escala esta solución. Sin embargo, siempre nos puede quedar la duda de, ¿es lo suficientemente buena como para evitar el acceso a la base de datos?</p>

<h3 id="full-text-search-en-sqlite">Full text search en SQLite</h3>
<p>Full text search es un termino que acuñan casi todos los motores de base de datos para designar a su implementación de la búsqueda de texto. Estos tipos de <em>índices</em> son muy potentes y son capaces de manejar gran cantidad de datos y realizar búsquedas muy diversas en muy poco tiempo. En el caso de SQLite, simplificando mucho, esto se lleva a cabo a través de varias tablas, algunas físicas y otras virtuales que se crean automáticamente para representar las estructuras de datos usadas, entre ellas un árbol B, podéis consultar más detalles técnicos en <a href="http://www.sqlite.org/fts3.html"><em>http://www.sqlite.org/fts3.html</em></a>.</p>

<h3 id="the-search-battle">The search battle</h3>
<p>Para comprobar qué método es mejor para realizar las búsquedas, vamos a enfrentarlos y ver qué es mejor, si buscar sobre datos ya cargados en memoria o volver a lanzar la búsqueda a la base de datos. Para ello he creado un proyecto, que tenéis disponible al final del artículo, donde realizar búsquedas sobre distintos conjuntos de datos con distintas palabras clave. Los conjuntos de datos provienen todos del mismo sitio, la lista de coches de Gran Turismo 6. En la comparativa tendremos por un lado la clase MemorySearch, que realiza las búsquedas basándose en el método <em>contains()</em> de esta forma:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span> <span class="nf">onSearch</span><span class="o">(</span><span class="n">String</span> <span class="n">term</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="n">Car</span> <span class="n">car</span> <span class="o">:</span> <span class="n">mCars</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">contained</span><span class="o">(</span><span class="n">term</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">(),</span>
                           <span class="n">car</span><span class="o">.</span><span class="na">getCountry</span><span class="o">(),</span>
                           <span class="n">car</span><span class="o">.</span><span class="na">getBrand</span><span class="o">(),</span>
                           <span class="n">car</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span>
                           <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">car</span><span class="o">.</span><span class="na">getYear</span><span class="o">())))</span> <span class="o">{</span>
                <span class="n">results</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">car</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">results</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">contained</span><span class="o">(</span><span class="n">String</span> <span class="n">term</span><span class="o">,</span> <span class="n">String</span><span class="o">...</span> <span class="n">texts</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="n">String</span> <span class="n">text</span> <span class="o">:</span> <span class="n">texts</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">text</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">text</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">term</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre>
</div>

<p>Por otro lado tenemos la clase FTSSearch, que realiza la misma búsqueda contra la base de datos SQLite usando Full text search.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">FTS_QUERY_TEMPLATE</span> <span class="o">=</span> <span class="s">"SELECT * FROM %s WHERE _id IN (SELECT docid FROM %s_fts WHERE content MATCH ?)"</span><span class="o">;</span>

<span class="o">...</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span> <span class="nf">onSearch</span><span class="o">(</span><span class="n">String</span> <span class="n">term</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Cursor</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">mDatabase</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">(</span>
            <span class="n">mQuery</span><span class="o">,</span> 
            <span class="k">new</span> <span class="n">String</span><span class="o">[]{</span> <span class="n">term</span> <span class="o">+</span> <span class="s">"*"</span> <span class="o">}</span>
        <span class="o">);</span>
        <span class="k">return</span> <span class="n">Car</span><span class="o">.</span><span class="na">fromCursor</span><span class="o">(</span><span class="n">cursor</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre>
</div>

<p>En ambos casos, el método <em>onSearch()</em> es sobre el que hacemos mediciones. Este método lo ejecutaremos 10 veces para cada conjunto de datos de forma que tengamos una medición algo más estable.</p>

<p>Los conjuntos de datos se distinguen por el número de elementos que contienen, tenemos siete distintos con 10, 100, 250, 500, 750, 1000 y 1200 elementos (el que este último sean 1200 en vez de 1250 no es más que porque GT6 no tiene más coches :-D).</p>

<p>Los resultados que obtenemos, ejecutando la aplicación sobre mi Xperia Z con Android 4.4.2 son los siguientes, si bien haciendo ejecuciones con otras versiones de Android los resultados cambian de magnitud pero, relativamente hablando, son similares entre ellos.</p>

<p><img src="/assets/images/search_methods_graph.png" alt="Gráfica comparativa Full text search" /> Gráfica comparando los resultados de la batalla</p>

<h3 id="un-claro-ganador">Un claro ganador</h3>
<p>Como podéis ver hay un claro ganador y este es la búsqueda con Full text search. A pesar de que haciendo esta búsqueda estamos consultando la base de datos, accediendo a disco y recreando los objetos en cada una de ellas, la velocidad de ejecución es claramente superior. Una solución que además escala muy bien, como podéis ver por la forma de gráfica, en contra de la solución de buscar sobre los datos en memoria.</p>

<p>Evidentemente puedes pensar que si tuviésemos una estructura de datos decente sobre la que buscar, por ejemplo creando ese árbol B, las cosas cambiarían, pero ello requeriría mucho más desarrollo, un mayor consumo de memoria de la aplicación y el tiempo de generación de esa estructura en memoria cada vez que arranque la aplicación o persistirla y aumentar aún más la cantidad de código requerido. Viendo el tiempo que tarda una búsqueda con FTS, no tiene sentido ninguno de estos planteamientos alternativos.</p>

<p>FTS no es gratis, evidentemente al crear una tabla de este tipo va a penalizar las escrituras y además incrementará el tamaño de la base de datos en disco, dos cosas que en el 99% de las aplicaciones no serán un gran problema. Lo normal en las aplicaciones móviles es escribir poco y leer muchas veces. Sobre el mayor tamaño en disco de la base de datos, tendrían que ser muchos los datos para ser un problema, unos pocos megas de más cuando los móviles manejan 4-8 GB de almacenamiento como mínimo por norma general no supondrá tampoco un problema.</p>

<p>Así que si vas a desarrollar una app, tienes datos persistidos en una base de datos SQLite, no reinventes la rueda y usa el soporte para Full text search. Si tus datos no se persisten y vienen de la nube, te puedes plantear crear una base de datos SQLite en memoria si no quieres repetir la búsqueda.</p>

<p>[github repo=”raycoarana/thesearchbattle”]</p>

	  ]]></description>
	</item>

	<item>
	  <title>Patrón Promise con jdeferred</title>
	  <link>//blog/2014/08/patron-promise-con-jdeferred/</link>
	  <author>Rayco Araña</author>
	  <pubDate>2014-08-08T00:02:48+02:00</pubDate>
	  <guid>//blog/2014/08/patron-promise-con-jdeferred/</guid>
	  <description><![CDATA[
	     <p>El patrón Promise es un patrón que trata de simplificar la estructura de nuestro código cuando trabajamos con operaciones asíncronas, algo que está a la orden del día en cualquier aplicación con interfaz gráfica, pero también importante en servicios que tienen distintas dependencias para realizar su trabajo y este puede realizarse en paralelo.</p>

<p>En primer lugar vamos a plantear el problema que trata de resolverse y cómo lo simplificamos con este patrón y en concreto con la librería <strong>jdeferred</strong>. Luego veremos el caso de particular de Android y el soporte específico que nos ofrece <strong>jdeferred</strong> que nos simplifican aún más el trabajo.</p>

<!--more-->

<h3 id="trabajo-en-paralelo-y-sincronización-de-hilos">Trabajo en paralelo y sincronización de hilos</h3>
<p>En cualquier aplicación que desarrollemos, siempre debemos trabajar al menos con dos hilos de ejecución. Un primer hilo encargado de pintar la interfaz gráfica y procesar la entrada del usuario; y un segundo hilo encargado de realizar las operaciones con recursos lentos como el acceso a disco, red, etc. Con esto conseguimos tener una interfaz gráfica que siempre responde al usuario y no parece que está colgada.</p>

<p>Por ejemplo, imaginemos que queremos en nuestra aplicación realizar tareas de procesamiento a razón de peticiones del usuario. Según el trabajo se vaya completando queremos notificar el progreso al usuario. Ahora mismo estamos en un mundo donde no hay PC/Smartphone/Tablet que no tenga varias CPUs, así que podemos lanzar varias cosas a ejecutarse al mismo tiempo, pero no podemos crear infinitos hilos -bueno en teoría sí, ya que el Sistema operativo compartirá el tiempo de CPU entre todos los hilos y si la memoria aguanta, podríamos tener muchos, pero no es lo más óptimo-. Así pues para empezar, nos creamos un <strong>pool de hilos</strong>.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">NUMBER_OF_CPUS</span> <span class="o">=</span> <span class="n">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">availableProcessors</span><span class="o">();</span>

<span class="kd">private</span> <span class="n">ExecutorService</span> <span class="n">mExecutorService</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
        <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_sample</span><span class="o">);</span>

        <span class="n">mExecutorService</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="n">NUMBER_OF_CPUS</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre>
</div>

<p>En este código estamos utilizando el número de CPUs disponibles, <strong>no quiere decir que esto sea lo más óptimo</strong>. De hecho, dependiendo del tipo de trabajo que vayamos a hacer, por ejemplo, una petición de lectura de disco, <strong>la CPU quedará un tanto ociosa mientras el disco responde y otro hilo podría adelantar trabajo</strong>. Luego muy probablemente un número un tanto mayor podría llegar a obtener mejores resultados, todo depende del tipo de trabajo a realizar. Para ello lo mejor es <strong>no tratar de optimizar desde el minuto 0</strong>, sino una vez tenemos resuelto el problema, probar otros valores para ver con cuál se obtienen mejores resultados.</p>

<p>Bien una vez tenemos nuestro pool de hilos, podemos agregar trabajo a realizar.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">doWorkInBackground</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Runnable</span> <span class="n">work</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">20</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
                    <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"Done "</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">"% of work on thread "</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">Log</span><span class="o">.</span><span class="na">e</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"Error doing background work"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">};</span>
    <span class="n">mExecutorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">work</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Como veis, no es más que crear un <code class="highlighter-rouge">Runnable</code> con el trabajo a realizar y llamar al método <code class="highlighter-rouge">submit()</code> de nuestro <code class="highlighter-rouge">ExecutorService</code> para que programe y ejecute el trabajo en un hilo en segundo plano.</p>

<p>El esquema anterior es muy simple, pero normalmente una aplicación es algo más compleja y lo primero que podemos agregar de complejidad es hacer un tratamiento al resultado de la ejecución de lo anterior. Por ejemplo, hacemos una librería que lee una imagen de disco de forma asíncrona con el anterior esquema, ¿dónde ponemos el código para hacer algo con esa imagen una vez se ha cargado? Lo primero que podemos pensar es llamar a esa tarea de procesar la imagen como última línea de código dentro del Runnable. Eso funciona, pero <strong>estamos acoplando dos funcionalidades distintas y afectando a la reusabilidad de nuestro código</strong>.</p>

<h3 id="patrón-promise-al-rescate">Patrón Promise al rescate</h3>
<p>La esencia del patrón Promise es precisamente esa, cuando lanzamos un trabajo asíncrono, se nos devuelve una promesa de que recibiremos en un momento futuro el resultado del mismo. Con esta promesa luego <strong>podemos encolar trabajo para que este se ejecute cuando el anterior ha finalizado</strong>.</p>

<p>Veamos cómo podemos aplicarlo a nuestro ejemplo. Lo primero será crear un <code class="highlighter-rouge">DeferredObject</code>, el cual controlará el estado de la promesa y sobre el que podemos actuar para <strong>notificar progreso, errores o resultado del trabajo</strong>. Los tres métodos esenciales son:</p>

<ul>
  <li><strong>notify()</strong> para notificar progreso en la ejecución de la tarea.</li>
  <li><strong>resolve()</strong> para dar la tarea por finalizada y enviar el resultado.</li>
  <li><strong>reject()</strong> para notificar errores en la operación.</li>
</ul>

<p>Por último, una vez hemos lanzado a ejecutar el trabajo, devolvemos la promesa.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="n">Promise</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Throwable</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">doWorkInBackground</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">DeferredObject</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Throwable</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">deferredObject</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DeferredObject</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Throwable</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;();</span>

    <span class="n">Runnable</span> <span class="n">work</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">20</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
                    <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"Done "</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">"% of work on thread "</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">());</span>
                    <span class="n">deferredObject</span><span class="o">.</span><span class="na">notify</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="o">}</span>

                <span class="n">deferredObject</span><span class="o">.</span><span class="na">resolve</span><span class="o">(</span><span class="s">"Finish!"</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">deferredObject</span><span class="o">.</span><span class="na">reject</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">};</span>
    <span class="n">mExecutorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">work</span><span class="o">);</span>

    <span class="k">return</span> <span class="n">deferredObject</span><span class="o">.</span><span class="na">promise</span><span class="o">();</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Y ya está, ahora si queremos usar este método y realizar acciones con cada posible caso solo nos queda ir agregando los <em>callbacks</em> necesarios. Estos son:</p>

<ul>
  <li><strong>then()</strong>. Qué hacer cuando el trabajo ha finalizado, puedes recibir hasta 3 parámetros, qué hacer después en caso de tener resultado, en caso de fallo y con cada progreso.</li>
  <li><strong>progress()</strong>. Qué hacer con cada notificación de progreso.</li>
  <li><strong>done()</strong>. Qué hacer solo cuando se finaliza correctamente.</li>
  <li><strong>fail()</strong>. Qué hacer cuando se produce un error.</li>
  <li><strong>always()</strong>. Qué hacer en cualquier caso, ya sea error o no.</li>
</ul>

<p>Todas estas llamadas se pueden ir encolando como comentábamos anteriormente. En principio todas ellas se ejecutan en el mismo hilo desde el que se produce la notificación, en este caso que estamos mostrando, todo ello se ejecuta desde el hilo que ejecuta el Runnable. Para comprobarlo, vamos a añadir este código a nuestro ejemplo.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>

    <span class="k">this</span><span class="o">.</span><span class="na">doWorkInBackground</span><span class="o">()</span>
            <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="k">new</span> <span class="n">DoneCallback</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onDone</span><span class="o">(</span><span class="n">String</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"then() on thread "</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}).</span><span class="na">progress</span><span class="o">(</span><span class="k">new</span> <span class="n">ProgressCallback</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onProgress</span><span class="o">(</span><span class="n">Integer</span> <span class="n">progress</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"progress() on thread "</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}).</span><span class="na">done</span><span class="o">(</span><span class="k">new</span> <span class="n">DoneCallback</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onDone</span><span class="o">(</span><span class="n">String</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"done() on thread "</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}).</span><span class="na">fail</span><span class="o">(</span><span class="k">new</span> <span class="n">FailCallback</span><span class="o">&lt;</span><span class="n">Throwable</span><span class="o">&gt;()</span> <span class="o">{</span>
                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onFail</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"fail() on thread "</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}).</span><span class="na">always</span><span class="o">(</span><span class="k">new</span> <span class="n">AlwaysCallback</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Throwable</span><span class="o">&gt;()</span> <span class="o">{</span>
                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onAlways</span><span class="o">(</span><span class="n">Promise</span><span class="o">.</span><span class="na">State</span> <span class="n">state</span><span class="o">,</span> <span class="n">String</span> <span class="n">resolved</span><span class="o">,</span> <span class="n">Throwable</span> <span class="n">rejected</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"always() on thread "</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">});</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Del resultado de la ejecución de este código, tendremos la siguiente salida por consola:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>I/JDEFERRED_DEMO﹕ Done 0% of work on thread 351
I/JDEFERRED_DEMO﹕ progress() on thread 351
I/JDEFERRED_DEMO﹕ Done 20% of work on thread 351
I/JDEFERRED_DEMO﹕ progress() on thread 351
I/JDEFERRED_DEMO﹕ Done 40% of work on thread 351
I/JDEFERRED_DEMO﹕ progress() on thread 351
I/JDEFERRED_DEMO﹕ Done 60% of work on thread 351
I/JDEFERRED_DEMO﹕ progress() on thread 351
I/JDEFERRED_DEMO﹕ Done 80% of work on thread 351
I/JDEFERRED_DEMO﹕ progress() on thread 351
I/JDEFERRED_DEMO﹕ Done 100% of work on thread 351
I/JDEFERRED_DEMO﹕ progress() on thread 351
I/JDEFERRED_DEMO﹕ then() on thread 351
I/JDEFERRED_DEMO﹕ done() on thread 351
I/JDEFERRED_DEMO﹕ always() on thread 351
</code></pre>
</div>

<h3 id="de-la-promesa-a-la-interfaz-de-usuario">De la promesa a la interfaz de usuario</h3>
<p>Ya tenemos lo que queríamos, una forma de generar <strong>APIs en nuestras aplicaciones que ejecutan trabajo de forma asíncrona</strong> y que de manera muy fácil podemos encolar a otras tareas a realizar. Pero, ¿cómo podemos ahora interactuar con la UI? Como hemos visto, ahora mismo todo se está ejecutando en un hilo en segundo plano. ¿Cómo podemos cambiar el código anterior para hacer que alguna de esas llamadas sean en el hilo de la UI y así poder realizar cambios en la misma?</p>

<p>Lo primero que necesitamos es utilizar la clase <code class="highlighter-rouge">AndroidDeferredManager</code> para gestionar los hilos, en vez de utilizar directamente el <code class="highlighter-rouge">ExecutorService</code>. Vamos a crear uno en el método onCreate.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="o">...</span>
    <span class="kd">private</span> <span class="n">AndroidDeferredManager</span> <span class="n">mDeferredManager</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
        <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_sample</span><span class="o">);</span>

        <span class="n">mDeferredManager</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AndroidDeferredManager</span><span class="o">(</span><span class="n">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="n">NUMBER_OF_CPUS</span><span class="o">));</span>

<span class="o">...</span>
</code></pre>
</div>

<p>Luego necesitamos cambiar en el método <code class="highlighter-rouge">doWorkInBackground()</code>, para en vez de utilizar el <code class="highlighter-rouge">ExecutorService</code>, utilizar el <code class="highlighter-rouge">DeferredManager</code> que hemos creado anteriormente. Por último, el <code class="highlighter-rouge">Promise</code> que generamos, debemos también hacerlo pasar por el <code class="highlighter-rouge">DeferredManager</code>, para que sea gestionado por él.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="kd">private</span> <span class="n">Promise</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Throwable</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">doWorkInBackground</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">...</span>

        <span class="n">mDeferredManager</span><span class="o">.</span><span class="na">when</span><span class="o">(</span><span class="n">work</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">mDeferredManager</span><span class="o">.</span><span class="na">when</span><span class="o">(</span><span class="n">deferredObject</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre>
</div>

<p>Con estos dos cambios, a priori si volvemos a ejecutar la aplicación veremos que ahora todos los callbacks se ejecutan en el hilo de la UI. Este es el comportamiento por defecto del <code class="highlighter-rouge">AndroidDeferredManager</code>, entiende que todo lo que se ejecuta a partir de la promesa será actualizar la interfaz gráfica. 
¿Y si queremos seguir en background? Pues lo que tendremos que cambiar es la interfaz que usamos para crear las clases anónimas y utilizar las que comienzan por <strong>Android</strong>. Veremos que ahora la interfaz nos obliga a implementar un segundo método <code class="highlighter-rouge">getExecutionScope()</code> con el qué podemos indicar en que hilo se debe ejecutar nuestro <em>callback</em>, pudiendo indicar si es UI o BACKGROUND. Vamos a probarlo, cambiamos el <em>callback</em> de <code class="highlighter-rouge">always()</code> y hacemos que la clase anónima ahora se cree a partir de la interfaz <code class="highlighter-rouge">AndroidAlwaysCallback</code> e implementamos el método <code class="highlighter-rouge">getExecutionScope()</code> devolviendo <strong>BACKGROUND</strong>.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="o">...</span>
<span class="o">}).</span><span class="na">always</span><span class="o">(</span><span class="k">new</span> <span class="n">AndroidAlwaysCallback</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Throwable</span><span class="o">&gt;()</span> <span class="o">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onAlways</span><span class="o">(</span><span class="n">Promise</span><span class="o">.</span><span class="na">State</span> <span class="n">state</span><span class="o">,</span> <span class="n">String</span> <span class="n">resolved</span><span class="o">,</span> <span class="n">Throwable</span> <span class="n">rejected</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"always() on thread "</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">());</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="n">AndroidExecutionScope</span> <span class="nf">getExecutionScope</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">AndroidExecutionScope</span><span class="o">.</span><span class="na">BACKGROUND</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">});</span>
<span class="o">...</span>
</code></pre>
</div>

<p>Y volvemos a ejecutar nuestro código.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>...
I/JDEFERRED_DEMO﹕ Done 0% of work on thread 414
I/JDEFERRED_DEMO﹕ progress() on thread 1
I/JDEFERRED_DEMO﹕ Done 20% of work on thread 414
I/JDEFERRED_DEMO﹕ progress() on thread 1
I/JDEFERRED_DEMO﹕ Done 40% of work on thread 414
I/JDEFERRED_DEMO﹕ progress() on thread 1
I/JDEFERRED_DEMO﹕ Done 60% of work on thread 414
I/JDEFERRED_DEMO﹕ progress() on thread 1
I/JDEFERRED_DEMO﹕ Done 80% of work on thread 414
I/JDEFERRED_DEMO﹕ progress() on thread 1
I/JDEFERRED_DEMO﹕ Done 100% of work on thread 414
I/JDEFERRED_DEMO﹕ always() on thread 414
I/JDEFERRED_DEMO﹕ progress() on thread 1
I/JDEFERRED_DEMO﹕ then() on thread 1
I/JDEFERRED_DEMO﹕ done() on thread 1
...
</code></pre>
</div>

<p>El resultado es que ahora el <em>always</em> se ha ejecutado en el hilo de background. El resto sigue en el hilo de la interfaz gráfica. Y con esto vemos que <strong>se ha adelantado la ejecución en este caso y a pesar del orden con el que hemos ido encadenando los callback, su ejecución es en un orden distinto debido al hilo en el que debe ejecutarse</strong>.</p>

<p>Como podéis imaginar podemos hacer muchos juegos con esta librería, pero lo dejamos para un siguiente artículo donde veremos cómo podemos hacer <strong>transformaciones de datos a base de filtros y pipes</strong> y cómo podemos además <strong>ejecutar trabajo en paralelo y realizar una acción final cuando todos estos trabajos en paralelo han terminado</strong> de manera muy fácil.</p>

<h3 id="código-más-limpio-y-fácil-de-leer">Código más limpio y fácil de leer</h3>
<p>La principal consecuencia de utilizar este patrón en nuestro código asíncrono es que nuestras APIs cumplen una máxima en el desarrollo de código limpio: <strong>los métodos no tienen parámetros de salida, solo un valor de retorno</strong>. En el caso asíncrono, es muy típico ver cómo hay que pasar un <em>callback</em> a un método para que cuando este acabe, nos devuelva por ahí el resultado. Con esta forma de trabajo, el método devuelve la promesa, con la que podremos obtener el valor más adelante, dejando un código más fácil de leer ya que es casi lineal y no obliga al desarrollador a estar dando saltos entre el código para seguir el flujo.</p>

<h3 id="cómo-la-obtengo">¿Cómo la obtengo?</h3>
<p>Pues desde su sitio web en <em><a href="http://jdeferred.org/">http://jdeferred.org/</a></em> o también a través de Gradle agregando:</p>

<div class="language-groovy highlighter-rouge"><pre class="highlight"><code><span class="n">compile</span> <span class="s1">'org.jdeferred:jdeferred-android:1.2.3'</span>
</code></pre>
</div>

<p>También os dejo en este repo el código de ejemplo.</p>

<p>[github repo=”raycoarana/jdeferred-demo”]</p>

	  ]]></description>
	</item>

	<item>
	  <title>Prototipado de apps con WireframeSketcher</title>
	  <link>//blog/2014/06/prototipado-de-apps-con-wireframesketcher/</link>
	  <author>Rayco Araña</author>
	  <pubDate>2014-06-19T10:59:16+02:00</pubDate>
	  <guid>//blog/2014/06/prototipado-de-apps-con-wireframesketcher/</guid>
	  <description><![CDATA[
	     <p>Aunque este es un blog fundamentalmente de desarrollo, hoy quería comentar un poco algo que nos toca siempre al comenzar una aplicación: la conceptualización. En el desarrollo móvil no es ningún secreto que tenemos <strong>el problema del tamaño de la pantalla</strong> -a pesar de los pseudo tablets que tenemos ahora por teléfonos-. A la hora de conceptualizar la aplicación, es fundamental utilizar una <strong>herramienta que nos permita de forma rápida poder organizar la información</strong> y cómo se comportará nuestra app.</p>

<p>Desde hace un tiempo he estado buscando la mejor herramienta para esta labor. Algo fundamental que debe tener una herramienta de este tipo es que <strong>respete las proporciones de los componentes nativos</strong> de la plataforma. Sin esto, conceptualizar una pantalla es un disparate, ya que estamos organizando la información en base a una premisa que puede ser falsa y a la hora de llevarla a la práctica, podemos ver que las cosas no nos caben -o nos sobra espacio-. En esta búsqueda me he topado con <strong>WireframeSketcher</strong>, una herramienta la mar de interesante, basada en Eclipse y con todos los elementos nativos de Android 4.X -también tiene los de iOS y Windows Phone entre otros-. Vamos a ver las principales características de esta herramienta.</p>

<!--more-->

<h3 id="proyectos-y-pantallas">Proyectos y pantallas</h3>
<p>En WireframeSketcher, como podemos imaginar al estar basado en Eclipse, tenemos un workspace en el que trabajamos y creamos nuestros proyectos. Un proyecto no será más que una serie de <em>screens</em> y <em>assets</em>.</p>

<p><a href="http://raycoarana.com/wp-content/uploads/2014/06/new_project.png"><img src="http://raycoarana.com/wp-content/uploads/2014/06/new_project-300x280.png" alt="new_project" /></a></p>

<p>En esta carpeta de <em>assets</em>, se agregarán inicialmente todos los iconos y componentes nativos del sistema. Por ejemplo, si usamos Android como base para nuestro proyecto, nos agregará todos los componentes e iconos de Android. También, como podemos ver en la siguiente imagen, nos agrega una primera pantalla con la que podemos trabajar.</p>

<p><a href="http://raycoarana.com/wp-content/uploads/2014/06/project-structure.png"><img src="http://raycoarana.com/wp-content/uploads/2014/06/project-structure.png" alt="project-structure" /></a></p>

<h3 id="elementos-de-pantalla">Elementos de pantalla</h3>
<p>Si vemos la parte derecha del espacio de trabajo, veremos que tenemos la paleta de componentes que podemos utilizar para crear nuestros wireframes. Estos están basados en una librería básica -que tienen todos los proyectos- y una librería de componentes incluidos en nuestro proyecto. Y digo incluidos en nuestro proyecto porque podemos crear nuestros propios componentes incluso crear proyectos que sirvan como librerías de componentes que podemos referenciar desde otros. Como veis una herramienta muy potente en este sentido.</p>

<p><a href="http://raycoarana.com/wp-content/uploads/2014/06/assets_library.png"><img src="http://raycoarana.com/wp-content/uploads/2014/06/assets_library-188x300.png" alt="assets_library" /></a></p>

<p>Los componentes con los que podemos trabajar son prácticamente todos los controles con los que contamos de forma nativa en Android. <em>ActionBar, CAB, Navigation Drawer, TextView, EditText, Button</em>, etc. Con unos pocos clicks de ratón, montamos una interfaz Android 4.X pura, de componentes nativos y proporciones correctas. Para editar estos componentes, basta con hacer doble-click sobre ellos para entrar en su jerarquía y poder así editar los elementos internos para cambiar imágenes, textos, color, tamaños de texto, etc.</p>

<p><a href="http://raycoarana.com/wp-content/uploads/2014/06/example_screen.png"><img src="http://raycoarana.com/wp-content/uploads/2014/06/example_screen-156x300.png" alt="example_screen" /></a></p>

<h3 id="iconos">Iconos</h3>
<p>Una cosa bastante reseñable y que le da un toque de calidad a nuestros wireframes es la posibilidad de utilizar el paquete de iconos nativos para poner elementos de menú, icono de la app o cualquier otra imagen.
Además de los iconos nativos, tenemos también otros paquetes de iconos -además de los que podemos añadir nosotros a nuestro proyecto por supuesto-, como la famosa fuente <strong>awesome</strong> entre otros paquetes que podemos descargarnos desde su web.</p>

<p><a href="http://raycoarana.com/wp-content/uploads/2014/06/icons_android.png"><img src="http://raycoarana.com/wp-content/uploads/2014/06/icons_android-245x300.png" alt="icons_android" /></a></p>

<p>Si queremos añadir imágenes o iconos a nuestro proyecto, podemos agregarlos a la carpeta <strong>assets/icons</strong>, en formato SVG.</p>

<h3 id="navegación">Navegación</h3>
<p>La navegación es otra cosa que podemos dejar indicada en nuestros proyectos, lo cual nos servirá para movernos a través de las pantallas mientras las desarrollamos, así como servir de enlaces cuando hagamos una exportación como veremos más adelante. Para añadir un enlace a alguno de los elementos, basta con seleccionar el elemento en el que queremos crear el enlace. Acto seguido, en el panel de la izquierda, donde tenemos las propiedades del elemento, cambiamos a la pestaña Links y desde ahí, seleccionamos la pantalla destino del enlace.</p>

<p><a href="http://raycoarana.com/wp-content/uploads/2014/06/links.png"><img src="http://raycoarana.com/wp-content/uploads/2014/06/links-300x150.png" alt="links" /></a></p>

<p>Podemos ver cómo queda el mapa de navegación por nuestra app creando un <em>Storyboard</em>. Este tipo de fichero nos permite agregar pantallas de nuestro proyecto las cuales podemos luego exportar como un HTML con enlaces entre ellas.</p>

<h3 id="exportación-a-html-pdf-y-png">Exportación a HTML, PDF y PNG</h3>
<p>Ya por último en este repaso a las principales funciones que nos presta WireframeSketcher, nos queda exportar nuestro proyecto para que otras personas puedan interactuar con ellas y hacerse una idea de cómo ha de ser la aplicación.</p>

<p>La primera forma que tenemos es HTML, como hemos comentado anteriormente, <strong>podremos exportar un Storyboard a HTML</strong>, teniendo así un subconjunto de pantallas navegables a través del navegador, algo que podemos entregar a un cliente para que valide que es así como se debe organizar la aplicación.</p>

<p>Otras formas más estáticas de exportar nuestro trabajo es usando ficheros PDF y/o imágenes en formato PNG.</p>

<h3 id="conclusiones">Conclusiones</h3>
<p>Después de experimentar distintas herramientas disponibles en el mercado, WireframeSketcher es para mí una de las mejores, por $99 tenemos una herramienta extensible y muy fiel al diseño final. Su uso es bastante sencillo y nos da la opción a exportar a HTML, algo ideal para enviar a clientes o compañeros. Como está integrado con Eclipse y como se puede instalar como plug-in también, nos permite integrar la herramienta en nuestro entorno habitual de trabajo -bueno si no estamos usando Android Studio- lo que nos permite la integración con otros plug-ins como control de versiones, pudiendo así colaborar y tener un historial de todo el trabajo realizado.</p>

<p>Más info y descarga: <a href="http://wireframesketcher.com/">http://wireframesketcher.com/</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>Calligraphy, fuentes personalizadas en Android</title>
	  <link>//blog/2014/06/calligraphy-fuentes-personalizadas-android/</link>
	  <author>Rayco Araña</author>
	  <pubDate>2014-06-16T21:15:48+02:00</pubDate>
	  <guid>//blog/2014/06/calligraphy-fuentes-personalizadas-android/</guid>
	  <description><![CDATA[
	     <p>Si hay una cosa que es un <strong>dolor de muelas</strong> en Android es cuando tienes que hacer una app que usa <strong>fuentes personalizadas</strong>. Aunque es incluso peor, si queremos usar la moderna Roboto, ya tenemos el lío formado, ya que en Android 2.3 no la tendremos tampoco. Y es que utilizar fuentes personalizadas es algo que está muy mal resuelto incluso aún hoy en la última versión del sistema (4.4.3 a día de hoy).</p>

<p>Básicamente para establecer una fuente distinta a las que trae el sistema por defecto, debemos instanciar la fuente (que normalmente tendremos en la carpeta <strong>assets</strong>) y asignarla a la vista de turno. El código sería algo así de horrible (horrible porque hacer esto por cada vista es una locura desde el punto de vista de mantenimiento de este tipo de código).</p>

<p>[code language=”java”]
Typeface tf = Typeface.createFromAsset(getAssets(), 
                                       “fonts/mycustomfont.ttf”);</p>

<p>TextView myView = (TextView) findViewById(android.R.id.text1);
myView.setTypeface(tf);
[/code]</p>

<p>Vamos a ver algunas formas para mejorar lo anterior y dejar que nuestras vistas se <strong>definan de forma declarativa</strong> por completo en el XML del layout.</p>

<!-- more -->

<p>[sh_margin margin=”20”]</p>

<h3 id="solución-1-controles-personalizados">Solución 1. Controles personalizados</h3>

<p>Una primera solución a este problema es utilizar controles personalizados para agregarles un atributo en el que indiquemos que fuente utilizar. Existen varias librerías que implementan esta forma de trabajo con las que simplemente debes utilizar sus vistas en vez de las vistas por defecto. Por ejemplo la librería <a href="https://github.com/neopixl/PixlUI">PixlUI</a> utiliza esta aproximación.</p>

<p>¿Desventajas de esta forma de trabajo? Pues que implica agregar una dependencia en todo el proyecto con esta librería, introduciendo sus atributos propios en las vistas. Además lo peor es que el editor de layouts pierde muchas veces la capacidad de mostrar el predictivo a la hora de escribir atributos. Además las vistas nos quedarán con esos <strong>nombres de controles enormes</strong> que incluyen el nombre del paquete de la clase y hacen menos legible nuestro código.</p>

<p>[code language=”xml”]
<?xml version="1.0" encoding="utf-8"?></p>

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:pixlui="http://schemas.android.com/apk/com.neopixl.pixlui" android:layout_width="match_parent" android:layout_height="match_parent">

    <com.neopixl.pixlui.components.textview.TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/text_of_my_view" android:gravity="center" android:textSize="36sp" pixlui:typeface="mycustomfont.ttf" />

...

</LinearLayout>
<p>[/code]</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="solución-2-calligraphy">Solución 2. Calligraphy</h3>

<p>Esta otra solución, implementada por esta librería llamada Calligraphy es tremendamente interesante, con <strong>una aproximación mucho más elegante</strong> a la hora de resolver el problema. En vez de regar nuestra aplicación con referencias a controles externos, esta librería crea un <strong>Wrapper tanto al objeto Context como al objeto LayoutInflater</strong> para interceptar toda referencia a las clases <em>TextView</em>, <em>Button</em>, <em>EditText</em>, <em>AutoCompleteTextView</em>, <em>MultiAutoCompleteTextView</em>, <em>CheckBox</em>, <em>RadioButton</em> y <em>ToggleButton</em>. Cuando detecta la instanciación de cualquiera de estos en nuestro <em>layout</em>, crea la fuente asociada y se la asigna a la vista. Esto además haciendo uso de una caché de fuentes y demás optimizaciones.</p>

<p>Para que esto funcione, lo que tendremos que hacer es <strong>envolver</strong> el contexto de nuestra actividad con este <strong>Wrapper</strong>, haciendo lo siguiente:</p>

<p>[code language=”java”]
@Override
protected void attachBaseContext(Context newBase) {
    super.attachBaseContext(new CalligraphyContextWrapper(newBase));
}
[/code]</p>

<p>Ahora solo nos queda indicar que fuente queremos usar en las vistas, retomando el ejemplo anterior, sería algo así:</p>

<p>[code language=”xml”]
<?xml version="1.0" encoding="utf-8"?></p>

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent">

    <TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/text_of_my_view" android:gravity="center" android:textSize="36sp" android:fontFamily="fonts/mycustomfont.ttf" />

...

</LinearLayout>
<p>[/code]</p>

<p>Por defecto como puedes ver se reutiliza la propiedad <strong>fontFamily</strong> para indicar la fuente que queremos usar, si bien esto nos puede acarrear problemas a futuro si Google cambia el uso de esa propiedad o le da otro uso (aunque esto sería muy raro). Calligraphy nos ofrece <strong>la posibilidad de usar un atributo personalizado</strong>, para ello primero debemos crearnos el atributo, en el fichero attrbs.xml por ejemplo.</p>

<p>[code language=”xml”]
<?xml version="1.0" encoding="utf-8"?></p>
<Resources>
    <attr name="customFont" />
</Resources>
<p>[/code]</p>

<p>Ahora necesitamos indicarle a Calligraphy cual es el atributo que vamos a usar.</p>

<p>[code language=”java”]
@Override
protected void attachBaseContext(Context newBase) {
    super.attachBaseContext(new CalligraphyContextWrapper(newBase, R.attr.customFont));
}
[/code]</p>

<p>Y ya solo nos queda utilizarlo en las vistas.</p>

<p>[code language=”xml”]
<?xml version="1.0" encoding="utf-8"?></p>

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent">

    <TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/text_of_my_view" android:gravity="center" android:textSize="36sp" customFont="fonts/mycustomfont.ttf" />

...

</LinearLayout>
<p>[/code]</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="conclusiones">Conclusiones</h3>

<p>Sin duda Calligraphy <strong>es lo que Google debería haber soportado en Android desde hace mucho tiempo</strong>. Integrándolo en la librería de compatibilidad abriría incluso su uso en cualquier versión de la API. Su solución es bastante limpia, no acopla todo nuestro código a controles personalizados y nos permite gestionar todo con estilos y temas, por lo que <strong>podemos centralizar el uso de las fuentes en nuestros ficheros de estilos</strong>. Os dejo el enlace al repositorio donde podéis encontrar el código y ver cómo funciona.</p>

<p>[github repo=”chrisjenx/Calligraphy”]</p>

	  ]]></description>
	</item>

	<item>
	  <title>Parcelables con Android AutoParcel</title>
	  <link>//blog/2014/06/parcelables-con-android-autoparcel/</link>
	  <author>Rayco Araña</author>
	  <pubDate>2014-06-09T22:29:34+02:00</pubDate>
	  <guid>//blog/2014/06/parcelables-con-android-autoparcel/</guid>
	  <description><![CDATA[
	     <p>Cuando vamos a crear una app en Android y tenemos que pasar datos entre <strong>Activities</strong> y/o <strong>Fragments</strong>, el sistema operativo nos brinda la posibilidad de usar un <strong>Bundle</strong>, ya sea a través del <strong>Intent **(y el Bundle de extras) o a través del método <em>**setArguments()**</em> de los Fragments. Esta es la manera idónea de pasar datos entre componentes, ya que **no crea acoplamientos poco deseables</strong>, además estos se gestionan de manera automática por el sistema, por lo que no debemos preocuparnos de qué pasa con ellos si el sistema ha tenido que recrear el Activity o Fragment debido al ciclo de vida de la aplicación.</p>

<p>El problema viene con los tipos de datos que nos permite almacenar un Bundle, estos son tipos básicos u objetos que implementen la interfaz <strong>Serializable</strong> o <strong>Parcelable</strong>. A la hora de implementar una u otra interfaz, la primera es sencilla, con solo hacer que nuestra clase implemente la interfaz Serializable el sistema <strong>por medio de reflexión es capaz de serializar el objeto a una representación binaria</strong> que se puede persistir. En el caso de Parcelable, sin embargo, debemos implementar dos métodos para serializar -_writeToParcel()<em>- y deserializar -_constructor</em>- el objeto. Además debemos escribirlo con sumo cuidado y en perfecto orden inverso o no funcionará, algo muy <strong>tedioso y difícil de mantener</strong>.</p>

<!-- more -->

<p>[sh_margin margin=”20”]</p>

<h3 id="porqué-usar-parcelable-sobre-serializable">¿Porqué usar Parcelable sobre Serializable?</h3>

<p>La principal razón para implementar Parcelable sobre Serializable es su velocidad de ejecución, se habla de hasta <strong>10x más rápido</strong> trabajar con objetos Parcelable. Si estamos en un entorno móvil, esto se traduce no solo en <strong>mayor rapidez</strong>, sino también en <strong>menor consumo de batería</strong>, algo que nunca debemos obviar a la hora de desarrollar apps.
Como decimos esta gran ventaja en cuanto a velocidad viene con un precio y es que la implementación y sobre todo el mantenimiento de este tipo de objetos es muy tediosa, siendo una tarea muy repetitiva y donde es muy fácil cometer errores.</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="android-autoparcel-al-rescate">Android AutoParcel al rescate</h3>

<p>Para solucionar esto, existe una librería muy interesante, o más que librería deberíamos hablar de <strong>plug-in para Gradle</strong>, que en tiempo de compilación, es capaz de generar el código de serialización y deserialización de nuestros objetos. Al ser en tiempo de compilación, no penaliza en absoluto la ejecución y nos beneficiamos de no tener que lidiar con los tediosos métodos de la interfaz Parcelable. Esta se llama <a href="https://github.com/frankiesardo/auto-parcel">Android AutoParcel</a> y es un port de la librería <a href="https://github.com/google/auto/tree/master/value">Google AutoValue</a>.</p>

<p>Vamos a ver cómo podemos integrar fácilmente este plug-in en nuestros proyectos y cómo usarlo. Lo primero será modificar el fichero raíz <strong>build.gradle</strong>, donde agregaremos en las dependencias la siguiente línea:</p>

<p>[code language=”groovy”]
buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath ‘com.android.tools.build:gradle:0.11.+’
        classpath ‘com.neenbedankt.gradle.plugins:android-apt:+’
    }
}</p>

<p>allprojects {
    repositories {
        mavenCentral()
    }
}
[/code]</p>

<p>Ahora nos vamos al fichero <strong>build.gradle</strong> de la aplicación, lo primero será aplicar el plug-in <strong>android-apt</strong> y luego agregamos en la sección de dependencias del proyecto tanto el procesador que generará el código en tiempo de compilación como la librería con las anotaciones de AutoParcel.</p>

<p>[code language=”groovy”]
apply plugin: ‘android’
apply plugin: ‘android-apt’</p>

<p>android {
    …
}</p>

<p>dependencies {
    compile fileTree(dir: ‘libs’, include: [‘*.jar’])
    compile ‘com.github.frankiesardo:android-auto-value:+’
    apt ‘com.github.frankiesardo:android-auto-value-processor:+’
}
[/code]</p>

<p>Ahora refrescamos el proyecto y vamos a escribir nuestro primer objeto con AutoParcel. Nuestras <strong>clases tendrán que ser abstractas</strong> y <strong>por cada propiedad que queramos que tenga, debemos generar un método abstracto</strong> para obtener su valor.</p>

<p>[code language=”java”]
import android.auto.value.AutoValue;
import android.os.Parcelable;</p>

<p>@AutoValue
public abstract class Foo implements Parcelable {</p>

<p>public abstract String fooString();
   public abstract int fooInteger();</p>

<p>}
[/code]</p>

<p>Solo nos falta una forma para poder construir objetos de tipo Foo, para ello agregamos un método estático con todos los valores e internamente y llamaremos en su interior al constructor del objeto que AutoParcel genera. El orden de los parámetros será el mismo con el que hemos escrito nuestra clase abstracta. Al momento de escribir este código muy probablemente la clase <strong>AutoValue_Foo</strong> aún no exista, debemos compilar para que el generador se ejecute y cree la clase.</p>

<p>[code language=”java”]
import android.auto.value.AutoValue;
import android.os.Parcelable;</p>

<p>@AutoValue
public abstract class Foo implements Parcelable {</p>

<p>public abstract String fooString();
   public abstract int fooInteger();</p>

<p>public static final Foo create(String fooString, int fooInteger) {
      return new AutoValue_Foo(fooString, fooInteger);
   }</p>

<p>}
[/code]</p>

<p>Y con esto ya está todo, de esta forma tan simple podemos ahora generar objetos que utilizar como argumentos o extras para los <em>Fragments _y _Activities</em> que usemos en nuestras aplicaciones, reduciendo la cantidad de código que tenemos que escribir considerablemente y sin caer en malas prácticas acoplando los componentes de nuestra aplicación.</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="más-info">Más info</h3>

<p>Puedes obtener más info y acceder al código en su página en GitHub.</p>

<p>[github repo=”frankiesardo/auto-parcel”]</p>

	  ]]></description>
	</item>

	<item>
	  <title>Timeline y Live Cards. Primeros pasos con Google Glass (V)</title>
	  <link>//blog/2014/04/timeline-y-live-cards-primeros-pasos-con-google-glass-iv/</link>
	  <author>Rayco Araña</author>
	  <pubDate>2014-04-29T23:00:32+02:00</pubDate>
	  <guid>//blog/2014/04/timeline-y-live-cards-primeros-pasos-con-google-glass-iv/</guid>
	  <description><![CDATA[
	     <p>Hace mucho que no escribía en el blog, entre otras cosas porque ando un poco liado con un proyecto personal. Además, como ya sabrás Google ha actualizado Google Glass a la versión de firmware XE16, subiendo la versión de Android a 4.4.2, actualizando también el GDK y por consiguiente, nos trae muchos cambios en la API. Esto ha implicado que parte de este artículo ya no tenga sentido, ya que Google ha eliminado la clase TimelineManager y por tanto, ya no es posible publicar en el Timeline tarjetas estáticas.</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="cambios-en-el-gdk">Cambios en el GDK</h3>

<p>Antes de continuar con la última entrega en esta serie de artículos de introducción a Google Glass, toca actualizar los anteriores. En el repositorio Git donde está el código de todos los artículos anteriores, podrás encontrar los proyectos actualizados con estos cambios, no son muchos y la mayoría no son más que cambios de nombres.</p>

<!-- more -->

<ul>
  <li>
    <p><strong>Nuevo permiso para comandos de voz propios.</strong> Si queremos utilizar comandos de voz que están fuera de la lista oficial de comandos, tendrás que añadir el permiso <em><strong>com.google.android.glass.permission.DEVELOPMENT</strong></em> en tu Manifest. Ni que decir tiene, que con este permiso no te permitirán subir la aplicación a MyGlass. Los comandos de voz permitidos están incluidos ahora como constantes en la clase <strong><em>VoiceTriggers.Command</em></strong> y en el tag <strong><em>trigger</em></strong> debemos indicar el comando usando el atributo <strong><em>command</em></strong>
.</p>
  </li>
  <li>
    <p><strong>Clase Card.</strong> Cambia el nombre del método <em>toView()</em> a <em>getView()</em>. Además existe una sobrecarga para la reutilización de vistas cuando se utiliza dentro de un CardScrollView.</p>
  </li>
  <li>
    <p><strong>Clases CardScrollView y CardScrollAdapter.</strong> Hay varios métodos que ya no existen o que ya no se pueden sobrescribir.</p>
  </li>
</ul>

<p>El resto de cambios afectan a API que no hemos visto, como la que ya hemos comentado, la desaparición de la clase <em>TimelineManager</em>. Si quieres ver el resto de cambios, puedes consultar las <a href="https://developers.google.com/glass/release-notes">Release Notes</a> que ha publicado Google.</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="static-cards">Static Cards</h3>

<p>Como decíamos anteriormente, las Static Cards ya no existen como tal. Anteriormente, usando la clase <em>TimelineManager</em> era posible publicar una tarjeta (objetos de tipo Card) directamente al Timeline, en la parte derecha que corresponde al pasado. El problema de esta API es que estas tarjetas no eran muy útiles, ya que el usuario no podía interactuar con ellas. No era posible asociarle un menú con el que poder interactuar y es esta seguramente la principal razón de su eliminación. Por lo tanto una Static Card no será más que una Live Card cuya vista permanece estática, aunque esto siempre será en la parte del futuro. ¿Y para el pasado? A mí esto me huele a próxima integración con la nueva API de Wearables que tenemos en Android y las tarjetas estáticas serán notificaciones.</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="live-cards">Live Cards</h3>

<p>Las Live Cards son por tanto la única forma que tenemos para insertar tarjetas en el Timeline de Google Glass (al menos por ahora). Para crear una tarjeta, basta con construir un objeto de tipo <strong><em>LiveCard</em></strong>, pasando el contexto y un tag con el que identificamos a la tarjeta.</p>

<p>[code language=”java”]
LiveCard liveCard = new LiveCard(this, “simple-card”);
[/code]</p>

<p>Una vez tenemos nuestra tarjeta, necesitamos decirle qué queremos mostrar. Existen dos tipos de Live Cards, en función de la frecuencia de actualización de la interfaz que necesitemos, las creadas a partir de una vista normal para baja frecuencia de actualización o las creadas sobre un SurfaceHolder, para por ejemplo, pintar con OpenGL, cuando se requiera una frecuencia de actualización alta. Es decir, si vamos a modificar el contenido de nuestra Live Card una o dos veces por segundo como mucho, la primera aproximación es la adecuada. Si por contra vamos a crear un compass, realidad aumentada o algo que necesite una frecuencia de 20-30 o más veces por segundo, debemos optar por la segunda opción.</p>

<p>Para las primeras, debemos asignarle una <strong>RemoteView</strong>. Esto ya nos debería sonar, en Android las <strong>RemoteView **se utilizan para cuando queremos crear Widgets y en cierta manera es justo lo que queremos hacer ahora, queremos darle a otra aplicación (el Timeline) una vista para que la muestre desde nuestra aplicación. Hay que tener esto claro para entender por qué no podemos poner cualquier vista en una **RemoteView</strong> y como es además su forma de actualización a través del objeto <strong>RemoveView</strong>, realmente <strong>nos estamos comunicando con otra aplicación</strong>, que vive en otro contexto distinto al de nuestra app.</p>

<p>[code language=”java”]
RemoteViews views = new RemoteViews(context.getPackageName(), 
                                    R.layout.view_of_my_livecard);
liveCard.setViews(views);
[/code]</p>

<p>Para las segundas, como comentamos necesitamos activar el <em>flag</em> de que nos vamos a encargar nosotros directamente del pintado y hacerlo mediante el <em>callback</em> que nos proporciona el <strong><em>SurfaceHolder</em></strong>. A partir de aquí podríamos crear un contexto de OpenGL por ejemplo y a partir de ahí crear lo que queramos. Pero eso ya no forma parte de esta serie de artículos de introducción a Google Glass, ya que lo podemos considerar como un aspecto avanzado y al que aplican las mismas reglas a partir de aquí a cualquier aplicación Android que use un SurfaceHolder.rfaceHolder_**.</p>

<p>[code language=”java”]
liveCard.setDirectRenderingEnabled(true);
liveCard.getSurfaceHolder().addCallback(callback);
[/code]</p>

<p>Una vez tenemos ya configurada nuestra Live Card, solo nos queda publicarla, para ello es tan sencillo como llamar al método <strong><em>publish()</em></strong>. Este método nos pide un parámetro para indicar la forma de publicación, <strong>REVEAL</strong> o <strong>SILENT</strong>. Con REVEAL le estamos indicando al Timeline que debe llevar al usuario a nuestra tarjeta recién publicada. Si por contra utilizamos SILENT, como nos podemos imaginar, la tarjeta se publicará sin <em>molestar</em> al usuario.</p>

<p>Pero… ¿realmente ya está? La verdad es que no. Si ejecutamos el código que hemos ido viendo y lo ejecutamos en una actividad, veremos que al salir de esta y volver al Timeline, nuestra tarjeta no existe. El problema es el ciclo de vida de nuestra aplicación y la tarjeta. Si recordáis del desarrollo de Widgets en Android, era siempre necesario tener un servicio en el que se apoyase el Widget y en el caso de las Live Cards nos ocurre igual, debemos crear un servicio y asociarlo a nuestra <em>LiveCard</em> utilizando el método <strong><em>attach()</em></strong> o creándolo directamente desde el propio servicio y que este gestione explícitamente su ciclo de vida.</p>

<p>[code language=”java”]
liveCard.attach(myService);
liveCard.publish(PublishMode.REVEAL);
[/code]</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="manos-a-la-obra">Manos a la obra</h3>

<p>Vamos a crear un ejemplo completo, vamos a crear un <strong>Voice Trigger con Prompt</strong> el cual lanzará un servicio. En este servicio, con cada Intent recibido, actualizaremos la Live Card para que muestre el texto que ha dictado el usuario. Además, llevaremos al usuario a dicha tarjeta una vez la hemos actualizado. Empezamos!</p>

<p>En primer lugar creamos el layout de nuestra Live Card. Vamos a hacer algo sencillo, simplemente un TextView en el que mostrar el texto.</p>

<p>[code language=”xml”]</p>
<TextView xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/my_card_content" android:layout_width="match_parent" android:layout_height="match_parent" />

<p>[/code]</p>

<p>Ahora vamos a crear el servicio, primero el esqueleto del mismo.</p>

<p>[code language=”java”]
public class Demo4Service extends Service {</p>

<div class="highlighter-rouge"><pre class="highlight"><code>@Override
public IBinder onBind(Intent intent) {
    return null;
}

@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    ...
    return START_STICKY;
}

@Override
public void onDestroy() {
    ...
} } [/code]
</code></pre>
</div>

<p>Ahora en el método <strong><em>onStartCommand()</em></strong> recibiremos cada uno de los Intent que el usuario vaya lanzando, así que lo primero será transformar el texto obtenido desde la lista a una simple String.</p>

<p>[code language=”java”]
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        ArrayList<String> voiceResults = intent.getExtras().getStringArrayList(RecognizerIntent.EXTRA_RESULTS);</String></p>

<div class="highlighter-rouge"><pre class="highlight"><code>    StringBuilder userContent = new StringBuilder();
    for (String voiceToken : voiceResults) {
        userContent.append(voiceToken);
        userContent.append(" ");
    } ... [/code]
</code></pre>
</div>

<p>Una vez tenemos ya la cadena a mostrar, vamos a crear la tarjeta. La tarjeta solo será necesaria crearla si es la primera vez que el usuario lanza el comando desde el inicio del servicio. Si este ya estaba en ejecución, la tarjeta ya existe y solo tendremos que actualizarla. Para esto es importante quedarnos con una instancia siempre de la tarjeta a nivel de servicio.</p>

<p>[code language=”java”]
…
        boolean haveToPublish = false;
        if (mLiveCard == null) {
            mLiveCard = new LiveCard(this, “simple-card”);
            mLiveCard.setAction(PendingIntent.getActivity(this, 0, new Intent(this, MenuActivity.class), 0));
            mRemoteViews = new RemoteViews(getPackageName(), R.layout.view_of_my_livecard);
            haveToPublish = true;
        }
…
[/code]</p>

<p>En el trozo de código anterior podemos ver cómo creamos la tarjeta y cómo le asignamos una acción. <strong>¡Ojo con esto porque es obligatorio!</strong>, si no definimos una acción a nuestra tarjeta, esta no se publicará. <strong>Si nuestra tarjeta no tiene de verdad ninguna función a mostrar</strong> cuando el usuario pulsa sobre ella, debemos lanzar una actividad, que no haga ni muestre nada, pero que reproduzca el <strong>sonido correspondiente para indicar al usuario que no existe acción posible</strong>. Esto es algo en lo que insisto mucho siempre a los desarrolladores, siempre, siempre, siempre hay que dar feedback al usuario de lo que está pasando, para que no se quede dando TAPs al TouchPad para ver si se muestra algo y no saber si es que no hay nada, no funciona o el dispositivo no funciona bien.</p>

<p>También podemos ver en este trozo de código cómo creamos la vista de nuestra tarjeta, que como hemos hablado anteriormente, se trata de una <strong>RemoteView</strong>. También nos guardamos la instancia de la <strong>RemoteView</strong> para poder actualizarla a posteriori.</p>

<p>Lo siguiente será un código que se ejecutará siempre, independientemente de si la tarjeta existía con anterioridad o no y es la actualización de la vista con el texto dictado por el usuario. Para ello utilizamos uno de los métodos soportados por el objeto <strong>RemoteViews</strong> para actualizar el contenido de esa vista remota. Una vez lo hemos actualizado, necesitamos reasignarlo a la Live Card para que esta tenga conocimiento del cambio.</p>

<p>[code language=”java”]
…
        mRemoteViews.setTextViewText(R.id.my_card_content, userContent);
        mLiveCard.setViews(mRemoteViews);
…
[/code]</p>

<p>Ya por último dentro del método <em>onStartCommand()</em> nos falta publicar la tarjeta, si no estaba ya publicada o navegar hacia ella si ya lo estaba. Para ello nos ayudamos del flag que hemos definido anteriormente de la siguiente forma:</p>

<p>[code language=”java”]
…
        if(haveToPublish) {
            mLiveCard.publish(LiveCard.PublishMode.REVEAL);
        } else {
            mLiveCard.navigate();
        }
…
[/code]</p>

<p>Bien, ya tenemos creada nuestra tarjeta, ahora necesitamos implementar el evento onDestroy de nuestro servicio, donde vamos a retirar nuestra tarjeta del Timeline.</p>

<p>[code language=”java”]
    @Override
    public void onDestroy() {
        if (mLiveCard != null &amp;&amp; mLiveCard.isPublished()) {
            mLiveCard.unpublish();
            mLiveCard = null;
        }
        super.onDestroy();
    }
[/code]</p>

<p>Ya lo tenemos todo, ahora solo nos falta configurar el <em>AndroidManifest</em> y el Voice Trigger con su Prompt como ya sabemos. Lo primero el Voice Trigger con el Prompt.</p>

<p>[code language=”xml”]</p>
<trigger keyword="@string/trigger_show_my_card">
    <input prompt="@string/prompt_show_my_card" />
</trigger>
<p>[/code]</p>

<p>Y declaramos el servicio en el <em>AndroidManifest</em>, asociándolo al Voice Trigger.</p>

<p>[code language=”xml”]
…
        <service android:name=".Demo4Service">
            <intent-filter>
                <action android:name="com.google.android.glass.action.VOICE_TRIGGER"></action>
            </intent-filter></service></p>

<div class="highlighter-rouge"><pre class="highlight"><code>        &lt;meta-data android:name="com.google.android.glass.VoiceTrigger"
            android:resource="@xml/show_my_card_trigger" /&gt;
    &lt;/service&gt; ... [/code]
</code></pre>
</div>

<p><strong>Recordad añadir el permiso para poder usar comandos personalizados</strong></p>

<p>[sh_margin margin=”20”]</p>

<h3 id="interactuando-con-nuestra-live-card">Interactuando con nuestra Live Card</h3>

<p>Anteriormente hemos visto cómo añadíamos una acción a nuestra Live Card, algo que es obligatorio, así que para completar nuestra aplicación, debemos implementar ese MenuActivity, el cual deberá ser transparente y que al mostrarse deberá abrir el menú. Además, si el menú se cierra, debe finalizarse y dejar la tarjeta en primer plano. Es todo código que ya hemos hecho en anteriores artículos, pero vamos a repasarlo rápidamente.</p>

<p>Creamos el fichero de menú.</p>

<p>[code language=”xml”]</p>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:id="@+id/one" android:title="One" />
    <item android:id="@+id/two" android:title="Two" />
</menu>
<p>[/code]</p>

<p>Creamos la actividad, en la cual no necesitaremos el método <em>onCreate()</em> ya que esta no va a tener interfaz gráfica. Para asociarle un menú a la actividad, lo hacemos como siempre. Para simplificar, no le vamos a añadir código para cuando se selecciona alguna de las opciones del menú, pero en caso de querer hacer algo, solo tendríamos que añadir el código que corresponda en el <strong>switch</strong>.</p>

<p>[code language=”java”]
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.my_menu, menu);
        return true;
    }</p>

<div class="highlighter-rouge"><pre class="highlight"><code>@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()) {
        default:
            return super.onOptionsItemSelected(item);
    }
} [/code]
</code></pre>
</div>

<p>Ahora para hacer que el menú se muestre al abrir la actividad y que la actividad se finalice cuando el menú se cierre implementamos los siguientes métodos.</p>

<p>[code language=”java”]
    @Override
    public void onAttachedToWindow() {
        super.onAttachedToWindow();
        openOptionsMenu();
    }</p>

<div class="highlighter-rouge"><pre class="highlight"><code>@Override
public void onOptionsMenuClosed(Menu menu) {
    finish();
} [/code]
</code></pre>
</div>

<p>Ya solo nos quedan un par de pequeños detalles para terminar nuestra aplicación y poder ver nuestra Live Card en acción. Lo primero es hacer nuestra actividad transparente, para eso vamos a sobrescribir el tema para esta actividad por uno que haga el fondo transparente y elimine cualquier animación de entrada de la actividad. En nuestro fichero de estilos agregamos el siguiente tema. Esperemos que en un futuro GDK este tema venga incluido por defecto en el sistema.</p>

<p>[code language=”xml”]
    <style name="MenuTheme" parent="@android:style/Theme.DeviceDefault">
        <item name="android:windowBackground">@android:color/transparent</item>
        <item name="android:colorBackgroundCacheHint">@null</item>
        <item name="android:windowIsTranslucent">true</item>
        <item name="android:windowAnimationStyle">@null</item>
    </style>
[/code]</p>

<p>Por último nos queda registrar la actividad en el <em>AndroidManifest</em>, donde le asociaremos el tema que hemos creado.</p>

<p>[code language=”xml”]
        <activity android:name=".MenuActivity" android:theme="@style/MenuTheme"></activity>
[/code]</p>

<p>Ejecutamos el proyecto y decimos “ok glass, show my card”, nos saltará el Prompt y a continuación, nuestra tarjeta.</p>

<p>Y con esto terminamos esta serie de artículos dedicados a Google Glass. Esto es lo básico y que marca diferencia con una aplicación Android, si bien me reservo aún algún tema como la autenticación con cuentas Google y no Google en Glass, pero hay muchas más cosas con las que experimentar ahí fuera y por ahora y hasta que exista un gran cambio de API en Google Glass, creo que es algo ya superado. Como siempre tenéis disponible el código en el repositorio de GitHub de esta serie de artículos bajo la carpeta <strong>4.Timeline</strong>.</p>

<p>[github repo=”raycoarana/google_glass_first_steps”]</p>

<p>[sh_margin margin=”20”]</p>

<h3 id="conclusiones">Conclusiones</h3>

<p>Con la utilización de Google Glass en el día a día vemos que a pesar del gran <strong><em>hype</em></strong> que tiene a su alrededor, no es más que un dispositivo Wearable y como tal, tiene grandes usos específicos, pero a su vez grandes limitaciones en su utilización. Es un complemento ideal para que te guíe por medio de una ciudad que no conoces, pero nada apropiado para leer o interactuar con ellas durante un largo tiempo. Como siempre serán las apps las que hagan de este dispositivo algo útil y básico en nuestro día a día o una mera anécdota en la historia de los gadgets. Así pues, ¡su futuro está en vuestras manos!</p>

<p><em>Happy coding explorers! :-)</em></p>

	  ]]></description>
	</item>

	<item>
	  <title>Cards API. Primeros pasos con Google Glass (IV)</title>
	  <link>//blog/2014/03/cards-api-primeros-pasos-google-glass-iv/</link>
	  <author>Rayco Araña</author>
	  <pubDate>2014-03-31T09:00:45+02:00</pubDate>
	  <guid>//blog/2014/03/cards-api-primeros-pasos-google-glass-iv/</guid>
	  <description><![CDATA[
	     <p>Hoy vamos a ver cómo crear interfaces gráficas para nuestro Glassware utilizando el concepto de tarjetas o Cards. Como sabéis, en Google Glass no hay botones, no hay forma de interactuar con elementos en la interfaz gráfica, sino que esta se compone de pantallas por las que podemos movernos, pantallas que se denominan tarjetas o Cards. El propio Timeline que se representa en la inferfaz inicial de Google Glass es un conjunto de tarjetas por las que podemos movernos. ¿Cómo podemos crear una interfaz de este estilo? Pues de forma muy fácil utilizando las clases CardScrollView, CardScrollAdapter y Card. ¡Vamos a ello!</p>

<!--more-->

<h3 id="crear-y-configurar-el-proyecto">Crear y configurar el proyecto</h3>

<p>Lo primero que debemos hacer será crear un nuevo proyecto. Para ello te recomiendo que sigas el artículo de <a href="/blog/2014/03/primeros-pasos-con-google-glass/">Primeros pasos con Google Glass</a>, donde vimos cómo crear y configurar un proyecto en Android Studio para Google Glass.</p>

<p>Una vez hemos creado el proyecto vacío, vamos a crear una actividad donde mostraremos nuestra interfaz de tarjetas. Creamos una clase con nombre <strong><em>CardsActivity</em></strong> y la añadimos al <strong><em>AndroidManifest.xml</em></strong>. Si quieres puedes añadirle un comando de voz para lanzar la aplicación o por simplicidad, puedes configurar el entorno para lanzar la aplicación directamente como ya comentamos en el <a href="/blog/2014/03/primeros-pasos-con-google-glass-ii/">segundo artículo de esta serie</a>. Recuerda que para poder lanzar la actividad desde el entorno esta tendrá que tener un <em>intent-filter</em> con la acción y categoría por defecto (<strong><em>…action.MAIN</em></strong> y <strong><em>…category.LAUNCHER</em></strong>). En esta ocasión no vamos a generar un layout para esta actividad, sino que usaremos directamente la vista CardScrollView como contenido de la actividad como veremos a continuación.</p>

<h3 id="cardscrollview-y-cardscrolladapter">CardScrollView y CardScrollAdapter</h3>

<p>La vista <strong><em>CardScrollView</em></strong> es la encargada de mostrar las tarjetas de forma lineal, permite moverse entre ellas con los gestos de <strong>Swipe hacia izquierda o derecha</strong> y todas las animaciones de aceleración al hacer el gesto de forma rápida para pasar rápido entre las distintas tarjetas. Para ello, el CardScrollView utiliza el mismo patrón que muchas otras vistas en Android, el <strong>patrón Adapter</strong>, para adaptar nuestro modelo al control visual que se muestra en pantalla. De esto se encarga el <strong><em>CardScrollAdapter</em></strong>, al cual el <strong><em>CardScrollView</em></strong> irá llamando para construir las tarjetas a mostrar en cada momento, encargándose por nosotros del ciclo de vida de las mismas.</p>

<p>Vamos a crear nuestra vista y asignarla como contenido de nuestra actividad, para ello en el método <strong><em>onCreate()</em></strong> de nuestra actividad hacemos lo siguiente:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CardsActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">CardScrollView</span> <span class="n">mCardScrollView</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>

        <span class="n">mCardScrollView</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CardScrollView</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        
        <span class="n">setContentView</span><span class="o">(</span><span class="n">mCardScrollView</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Ya tenemos nuestra vista, pero ahora mismo poco va a mostrar ya que no tiene contenido. Vamos a añadirle algunas tarjetas, para ello vamos a crear y configurar un <strong><em>CardScrollAdapter</em></strong>. Para crear un <strong><em>CardScrollAdapter</em></strong>, tendremos que heredar la clase e implementar algunos métodos. Lo normal sería tener un modelo de datos asociado a cada tarjeta, pero para nuestro ejemplo, vamos a prescindir de ello para simplificar, por lo que solo tendremos que implementar el método <em><strong>getCount()</strong></em> y <em><strong>getView()</strong></em> para indicar el número de tarjetas y la vista de cada una de ellas respectivamente. Vamos a crear cuatro tarjetas, así que el código de nuestro Adapter quedaría algo así, donde delegamos la creación de las vistas en métodos que veremos a continuación.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="n">CardScrollAdapter</span> <span class="n">mCardScrollAdapter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CardScrollAdapter</span><span class="o">()</span> <span class="o">{</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCount</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">4</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">Object</span> <span class="nf">getItem</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">View</span> <span class="nf">getView</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">View</span> <span class="n">view</span><span class="o">,</span> <span class="n">ViewGroup</span> <span class="n">viewGroup</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">View</span> <span class="n">cardView</span><span class="o">;</span>
            <span class="k">switch</span> <span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
                    <span class="n">cardView</span> <span class="o">=</span> <span class="n">getFirstCardView</span><span class="o">();</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
                    <span class="n">cardView</span> <span class="o">=</span> <span class="n">getSecondCardView</span><span class="o">();</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
                    <span class="n">cardView</span> <span class="o">=</span> <span class="n">getThirdCardView</span><span class="o">();</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">default</span><span class="o">:</span> <span class="c1">//case 3:</span>
                    <span class="n">cardView</span> <span class="o">=</span> <span class="n">getFourthCardView</span><span class="o">();</span>
                    <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">cardView</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findIdPosition</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findItemPosition</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">};</span>
</code></pre>
</div>

<p>Como habéis visto, el <strong><em>CardScrollAdapter</em></strong>, como cualquier otro Adapter, lo que nos pide son vistas, por lo que podríamos crear cualquier tipo de vista para nuestras tarjetas. Sin embargo, Google ha incluido en el SDK la clase <strong><em>Card</em></strong> que nos <strong>permite crear vistas de forma sencilla</strong>, con el estilo de Glass sin tener que preocuparnos por nada. El que hayamos configurado nuestro Adapter con 4 elementos no es casualidad, vamos a ver las principales configuraciones de tarjetas que podemos crear con esta clase.</p>

<h3 id="tarjeta-simple-con-texto">Tarjeta simple con texto</h3>

<p>La primera tarjeta que crearemos será una sencilla que solo contendrá un texto. La clase <strong><em>Card</em></strong> requiere como parámetro el contexto y luego le asignaremos los datos a mostrar por la misma. Cuando hemos acabado, llamamos al método <strong><em>toView()</em></strong> para obtener la vista resultante.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="kd">private</span> <span class="n">View</span> <span class="nf">getFirstCardView</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Card</span> <span class="n">card</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Card</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="n">card</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"Tarjeta simple de texto"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">card</span><span class="o">.</span><span class="na">toView</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre>
</div>

<p>El resultado de este código es la siguiente tarjeta:</p>

<p><img src="/assets/images/tarjeta_texto.png" alt="Tarjeta simple con texto" /> Tarjeta simple con texto</p>

<h3 id="tarjeta-con-texto-e-imagen-a-la-izquierda">Tarjeta con texto e imagen a la izquierda</h3>

<p>Para añadir una imagen a la izquierda de la tarjeta, solo tendremos que llamar al método <strong><em>addImage()</em></strong> y establecer con <strong><em>setImageLayout()</em></strong> que esta esté alineada a la izquierda.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="kd">private</span> <span class="n">View</span> <span class="nf">getSecondCardView</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Card</span> <span class="n">card</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Card</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="n">card</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"Tarjeta con imagen a la izquierda"</span><span class="o">);</span>
        <span class="n">card</span><span class="o">.</span><span class="na">setImageLayout</span><span class="o">(</span><span class="n">Card</span><span class="o">.</span><span class="na">ImageLayout</span><span class="o">.</span><span class="na">LEFT</span><span class="o">);</span>
        <span class="n">card</span><span class="o">.</span><span class="na">addImage</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">drawable</span><span class="o">.</span><span class="na">audi</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">card</span><span class="o">.</span><span class="na">toView</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre>
</div>

<p>El resultado lo podéis ver a continuación:</p>

<p><img src="/assets/images/tarjeta_texto_imagen_izq.png" alt="Tarjeta con texto e imagen a la izquierda" /> Tarjeta con texto e imagen a la izquierda</p>

<h3 id="tarjeta-con-texto-e-imagen-al-fondo">Tarjeta con texto e imagen al fondo</h3>

<p>Si queremos que la imagen no esté a la izquierda sino que esté de fondo de la tarjeta, simplemente cambiamos el ImageLayout de la misma. Esto creará un ligero degradado a negro tras el texto para ganar contraste sobre la imagen.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="kd">private</span> <span class="n">View</span> <span class="nf">getThirdCardView</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Card</span> <span class="n">card</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Card</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="n">card</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"Tarjeta con imagen al fondo"</span><span class="o">);</span>
        <span class="n">card</span><span class="o">.</span><span class="na">setImageLayout</span><span class="o">(</span><span class="n">Card</span><span class="o">.</span><span class="na">ImageLayout</span><span class="o">.</span><span class="na">FULL</span><span class="o">);</span>
        <span class="n">card</span><span class="o">.</span><span class="na">addImage</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">drawable</span><span class="o">.</span><span class="na">opel</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">card</span><span class="o">.</span><span class="na">toView</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre>
</div>

<p>La tarjeta resultante es la siguiente:</p>

<p><img src="/assets/images/tarjeta_texto_imagen_fondo.png" alt="Tarjeta con imagen de fondo" /> Tarjeta con imagen de fondo</p>

<h3 id="tarjeta-con-texto-nota-al-pie-y-varias-imágenes-a-la-izquierda">Tarjeta con texto, nota al pie y varias imágenes a la izquierda</h3>

<p>Podemos agregar varias imágenes, creándonos un mosaico con ellas. También podremos acompañar el texto principal con un texto al pie de la tarjeta.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="kd">private</span> <span class="n">View</span> <span class="nf">getFourthCardView</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Card</span> <span class="n">card</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Card</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="n">card</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"Tarjeta con texto al pie y varias imagenes"</span><span class="o">);</span>
        <span class="n">card</span><span class="o">.</span><span class="na">setFootnote</span><span class="o">(</span><span class="s">"Texto pie de página"</span><span class="o">);</span>
        <span class="n">card</span><span class="o">.</span><span class="na">setImageLayout</span><span class="o">(</span><span class="n">Card</span><span class="o">.</span><span class="na">ImageLayout</span><span class="o">.</span><span class="na">LEFT</span><span class="o">);</span>
        <span class="n">card</span><span class="o">.</span><span class="na">addImage</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">drawable</span><span class="o">.</span><span class="na">audi</span><span class="o">);</span>
        <span class="n">card</span><span class="o">.</span><span class="na">addImage</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">drawable</span><span class="o">.</span><span class="na">opel</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">card</span><span class="o">.</span><span class="na">toView</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre>
</div>

<p>El resultado es la siguiente tarjeta:</p>

<p><img src="/assets/images/tarjeta_multiples_img.png" alt="Tarjeta con múltiples imágenes y pie" /> Tarjeta con múltiples imágenes y pie</p>

<p>Ahora que ya tenemos nuestro Adapter con sus vistas, nos falta asignarlo al <strong><em>CardScrollView</em></strong> y activar este. Para ello añadimos estas líneas en el método <strong><em>onCreate()</em></strong> de la actividad.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="o">...</span>
<span class="n">mCardScrollView</span><span class="o">.</span><span class="na">setAdapter</span><span class="o">(</span><span class="n">mCardScrollAdapter</span><span class="o">);</span>
<span class="n">mCardScrollView</span><span class="o">.</span><span class="na">activate</span><span class="o">();</span>
<span class="o">...</span>
</code></pre>
</div>

<p>Con esto si lanzamos la aplicación veremos la interfaz de tarjetas con cada una de ellas. Pero, ¿cómo podemos interactuar con ellas? No podemos poner un botón, implementar el OnClickListener no servirá de nada. ¿Entonces? ¿Cómo podemos darle opciones al usuario para realizar acciones sobre cada tarjeta?</p>

<h3 id="interactuando-con-una-tarjeta">Interactuando con una tarjeta</h3>

<p>Para interactuar con una tarjeta, debemos asignar un <strong><em>OnItemClickListener</em></strong> al <strong><em>CardScrollView</em></strong>. Cada vez que el usuario haga <em>TAP</em>, la vista nos notificará con la información relativa a la tarjeta sobre la que se ha realizado la pulsación en el TouchPad. En el método <strong><em>onCreate()</em></strong> de nuestra actividad, añadimos la siguiente línea:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="o">...</span>
<span class="n">mCardScrollView</span><span class="o">.</span><span class="na">setOnItemClickListener</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
<span class="o">...</span>
</code></pre>
</div>

<p>Ahora nos queda hacer que nuestra actividad implemente esa interfaz <strong><em>OnItemClickListener</em></strong> y añadir el método <strong><em>OnItemClick()</em></strong>.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="o">...</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CardsActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="kd">implements</span> <span class="n">AdapterView</span><span class="o">.</span><span class="na">OnItemClickListener</span> <span class="o">{</span>

    <span class="o">...</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onItemClick</span><span class="o">(</span><span class="n">AdapterView</span><span class="o">&lt;?&gt;</span> <span class="n">parent</span><span class="o">,</span> <span class="n">View</span> <span class="n">view</span><span class="o">,</span> <span class="kt">int</span> <span class="n">position</span><span class="o">,</span> <span class="kt">long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Bien ahora que ya somos notificados sobre la pulsación sobre una tarjeta, ¿cómo podemos mostrar al usuario operaciones que hacer sobre estos elementos que está viendo? Pues haciendo uso de los menús de Android. En Google Glass, los menús se comportan de manera distinta, mostrándose cada entrada de menú a pantalla completa como tarjetas sobre las que el usuario puede moverse (adivinad qué vista utilizará el sistema operativo para implementar esto). La manera de implementarlo por tanto es muy conocida por cualquier desarrollador Android, pero vamos a repasarla.</p>

<p>Lo primero será crearnos la definición de nuestro menú, creamos un fichero xml en <strong><em>menu/activity_cards.xml</em></strong>. Los iconos los tenéis disponibles en el repositorio junto con el resto del código.</p>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="nt">&lt;menu</span> <span class="na">xmlns:android=</span><span class="s">"http://schemas.android.com/apk/res/android"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;item</span> <span class="na">android:id=</span><span class="s">"@+id/menu_read_aloud"</span>
          <span class="na">android:icon=</span><span class="s">"@drawable/ic_read_aloud"</span>
          <span class="na">android:title=</span><span class="s">"@string/menu_read_aloud"</span> <span class="nt">/&gt;</span>

    <span class="nt">&lt;item</span> <span class="na">android:id=</span><span class="s">"@+id/menu_share"</span>
        <span class="na">android:icon=</span><span class="s">"@drawable/ic_share"</span>
        <span class="na">android:title=</span><span class="s">"@string/menu_share"</span> <span class="nt">/&gt;</span>

    <span class="nt">&lt;item</span> <span class="na">android:id=</span><span class="s">"@+id/menu_close"</span>
        <span class="na">android:icon=</span><span class="s">"@drawable/ic_close"</span>
        <span class="na">android:title=</span><span class="s">"@string/menu_close"</span> <span class="nt">/&gt;</span>

<span class="nt">&lt;/menu&gt;</span>
</code></pre>
</div>

<p>Una vez tenemos nuestro menú, vamos a incorporarlo a la actividad. Para ello implementamos los métodos <strong><em>onCreateOptionsMenu()</em></strong> y <strong><em>onOptionsItemSelected()</em></strong> para crear el menú cuando sea necesario y realizar acciones cuando se seleccione un elemento del menú. Si quisieramos personalizar el menú en función del elemento sobre el que se hace la selección, podemos implementar el método <strong><em>onPrepareOptionsMenu()</em></strong> y ocultar/mostrar aquellos elementos que nos interese.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="o">...</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">onCreateOptionsMenu</span><span class="o">(</span><span class="n">Menu</span> <span class="n">menu</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">getMenuInflater</span><span class="o">().</span><span class="na">inflate</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">menu</span><span class="o">.</span><span class="na">activity_cards</span><span class="o">,</span> <span class="n">menu</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">onOptionsItemSelected</span><span class="o">(</span><span class="n">MenuItem</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">getItemId</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">case</span> <span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">menu_read_aloud</span><span class="o">:</span>
                <span class="n">onMenuReadAloud</span><span class="o">();</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">menu_share</span><span class="o">:</span>
                <span class="n">onMenuShare</span><span class="o">();</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">menu_close</span><span class="o">:</span>
                <span class="n">onMenuClose</span><span class="o">();</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">onOptionsItemSelected</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">...</span>
</code></pre>
</div>

<p>Ya tenemos muestro menú montado, solo nos falta relacionar el <strong><em>onItemClick</em></strong> del <strong><em>CardScrollView</em></strong> con la apertura del menú y escribir código para cada una de las acciones. Lo primero es tan sencillo como esto:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onItemClick</span><span class="o">(</span><span class="n">AdapterView</span><span class="o">&lt;?&gt;</span> <span class="n">parent</span><span class="o">,</span> <span class="n">View</span> <span class="n">view</span><span class="o">,</span> <span class="kt">int</span> <span class="n">position</span><span class="o">,</span> <span class="kt">long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">openOptionsMenu</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre>
</div>

<p>Pero vamos a complicar un poco el caso, por ejemplo no queremos que para el primer elemento del <strong><em>CardScrollView</em></strong> se muestre un menú. ¿Qué deberíamos hacer? Pues por un lado evitar llamar al método <strong><em>openOptionsMenu()</em></strong> cuando el usuario haga TAP sobre el primer elemento y muy importante, darle <strong>feedback al usuario de que en ese elemento no hay acciones</strong> posibles a realizar. Para esto segundo haremos uso del <strong><em>AudioManager</em></strong> y los sonidos del sistema, que específicamente en Glass están representados por constantes de la clase <strong><em>Sounds</em></strong>, en concreto la constante <em>DISALLOWED</em>. De la misma forma, para darle feedback al usuario de la apertura del menú, haremos lo mismo pero con la constante <em>TAP</em>.</p>

<p>Lo primero, obtener una instancia al <strong><em>AudioManager</em></strong> en el método <strong><em>onCreate()</em></strong>.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="kd">private</span> <span class="n">AudioManager</span> <span class="n">mAudioManager</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>

        <span class="n">mAudioManager</span> <span class="o">=</span> <span class="o">(</span><span class="n">AudioManager</span><span class="o">)</span> <span class="n">getSystemService</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">AUDIO_SERVICE</span><span class="o">);</span>
        <span class="o">...</span>
</code></pre>
</div>

<p>Ahora en el método <strong><em>onItemClick()</em></strong> hacemos lo siguiente:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onItemClick</span><span class="o">(</span><span class="n">AdapterView</span><span class="o">&lt;?&gt;</span> <span class="n">parent</span><span class="o">,</span> <span class="n">View</span> <span class="n">view</span><span class="o">,</span> <span class="kt">int</span> <span class="n">position</span><span class="o">,</span> <span class="kt">long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">position</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">mAudioManager</span><span class="o">.</span><span class="na">playSoundEffect</span><span class="o">(</span><span class="n">Sounds</span><span class="o">.</span><span class="na">DISALLOWED</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">mAudioManager</span><span class="o">.</span><span class="na">playSoundEffect</span><span class="o">(</span><span class="n">Sounds</span><span class="o">.</span><span class="na">TAP</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">openOptionsMenu</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre>
</div>

<p>Ya tenemos la funcionalidad que queríamos, ahora el primer elemento no muestra el menú y da feedback al usuario de ello. Vamos ahora a darle funcionalidad a las acciones que teníamos. No vamos a implementarlas de verdad para no extendernos demasiado, solo vamos mostrar en el log del sistema que se han ejecutado.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">onMenuReadAloud</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="s">"DEMO3"</span><span class="o">,</span> <span class="s">"onMenuReadAloud()"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">onMenuShare</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="s">"DEMO3"</span><span class="o">,</span> <span class="s">"onMenuShare()"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">onMenuClose</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="s">"DEMO3"</span><span class="o">,</span> <span class="s">"onMenuClose()"</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre>
</div>

<p>Y con esto lo tenemos todo, al ejecutar la aplicación y hacer TAP sobre una de las tarjetas con menú, se nos mostrará dándonos la opción a seleccionar la acción que queremos realizar.</p>

<p><img src="/assets/images/menu_read_aloud.png" alt="ReadAloud" />
<img src="/assets/images/menu_share.png" alt="Share" />
<img src="/assets/images/menu_close.png" alt="Close" /></p>

<h3 id="buenas-prácticas">Buenas prácticas</h3>

<p>Por último vamos a comentar algunas buenas prácticas que envuelven a las interfaces en general de Googlas Glass y que tienen que ver con estos elementos que hemos visto hoy. Lo primero es la recomendación de siempre utilizar un <strong><em>CardScrollView</em></strong> en nuestras interfaces, aunque solo vayamos a mostrar una sola tarjeta. <strong><em>CardScrollView</em></strong> tiene esos <strong>efectos de rebote animados</strong> cuando el usuario llega al final, dándole un feedback muy importante de la no existencia de más elementos. Así pues, a menos que vayamos a utilizar el Swipe izquierda o derecha para otra cosa, hagamos uso del <strong><em>CardScrollView</em></strong>.</p>

<p>Otra buena práctica muy relacionada con ese feedback es informar al usuario de si su <strong>acción sobre el TouchPad ha sido reconocida o no</strong> mediante sonidos, como hemos podido ver en el código ejemplo. Debemos informar al usuario de qué ocurre cuando hace TAP, reproduciendo el sonido adecuado si no hay acción disponible.</p>

<p>Y hasta aquí hemos llegado en este artículo, como siempre tenéis disponible el código en el respositorio de GitHub de esta serie de artículos bajo la carpeta <strong>3.CardAPI</strong>.</p>

<p>[github repo=”raycoarana/google_glass_first_steps”]</p>

<h3 id="continuará">Continuará…</h3>

<p>Ahora que ya sabemos como manejar las tarjetas y mostrar acciones sobre ellas, vamos a ver cómo podemos trabajar con el Timeline, veremos cómo podemos crear tarjetas estáticas, tarjetas dináminas e incorporarlas en el Timeline, pudiendo el usuario interactuar con ellas sin la necesidad de abrir nuestra aplicación.</p>

	  ]]></description>
	</item>


</channel>
</rss>
